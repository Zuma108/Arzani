<!DOCTYPE html>
<html lang="en">
<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title || 'Arzani X - Where real AI experts build real businesses' %></title>
    <link rel="icon" href="/figma design exports/images.webp/arzani-icon-nobackground.png" type="image/png">
    <!-- Authentication token for API calls -->
    <% if (typeof user !== 'undefined' && user && user.token) { %>
    <meta name="auth-token" content="<%= user.token %>">
    <% } %><!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Markdown rendering libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.7/dist/purify.min.js"></script>
    
    <!-- Syntax highlighting for code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Arzani-X Styles -->
    <link rel="stylesheet" href="/css/arzani-x.css">
    <link rel="stylesheet" href="/css/markdown-enhanced.css">
    
    <!-- Ensure table styles apply correctly -->
    <style>
      /* Critical table styles for GFM compatibility */
      .message-content table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        overflow: hidden;
        font-size: 0.875rem;
      }
      
      .message-content th, .message-content td {
        padding: 0.75rem 1rem;
        text-align: left;
        border: 1px solid #e5e7eb;
      }
      
      .message-content th {
        background-color: #f9fafb;
        font-weight: 600;
      }
      
      .message-content tr:nth-child(even) {
        background-color: #f9fafb;
      }
      
      /* Ensure Arzani-specific table styles have high specificity */
      .arzani-table-wrapper {
        width: 100% !important;
        overflow-x: auto !important;
        margin: 1.5rem 0 !important;
      }
      
      .arzani-table {
        width: 100% !important;
        table-layout: auto !important;
      }
      
      /* Scroll to Bottom Button Styles */
      .scroll-to-bottom-btn {
        position: fixed;
        bottom: 120px;
        right: 20px;
        width: 40px;
        height: 40px;
        background-color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        z-index: 30;
        transition: all 0.2s ease;
        border: 1px solid #e5e7eb;
        color: #6b7280;
      }
      
      .scroll-to-bottom-btn:hover {
        background-color: #f9fafb;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      
      .scroll-to-bottom-btn.hidden {
        opacity: 0;
        visibility: hidden;
        transform: translateY(10px);
      }
      
      .scroll-to-bottom-btn.visible {
        opacity: 1;
        visibility: visible;
        animation: fadeInUp 0.3s ease forwards;
      }
      
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
<!-- External JavaScript files -->    <script src="/js/arzani-x.js"></script>
    <script src="/js/arzani-x-persistence.js"></script>    <script src="/js/markdown-renderer.js"></script>
    <!-- Enhanced Thinking Panel System -->
    <script src="/js/thinking-panel.js"></script>
    <!-- A2A Frontend Logger -->
    <script src="/js/a2a-frontend-logger.js"></script>
    <!-- Debug Helper for Arzani client initialization -->    <script src="/js/arzani-debug-helper.js"></script>
    <!-- Test Helper for Arzani client -->
    <script src="/js/arzani-test-helper.js"></script>
    <!-- Edit Helper for message editing -->
    <script src="/js/arzani-edit-helper.js"></script>
    <!-- Session Synchronizer for consistent conversations -->
    <script src="/js/arzani-session-sync.js"></script>
    <!-- Table Rendering Test Helper -->
    <script src="/js/table-render-test.js"></script>
    <!-- Typewriter Speed Test Helper -->
    <script src="/js/typewriter-speed-test.js"></script>
    <!-- Comprehensive Typewriter Test -->
    <script src="/js/typewriter-comprehensive-test.js"></script>
    <!-- Scroll to Bottom Manager -->
    <script src="/js/scroll-to-bottom.js"></script>
</head>
<body class="bg-white font-['Segoe_UI'] m-0 p-0 h-full overflow-x-hidden">
      <!-- AI Disclaimer Popup -->
    <div id="disclaimerPopup" class="disclaimer-popup hidden">
        <div class="disclaimer-header">
            <div class="disclaimer-title">
                <span class="disclaimer-icon">‚ö†Ô∏è</span>
                AI-Generated Financial & Legal Information
            </div>
            <button id="disclaimerClose" class="disclaimer-close" aria-label="Close disclaimer">
                √ó
            </button>
        </div>
        <div class="disclaimer-content">
            <p><strong>Important Notice:</strong> The information provided by our AI agents is for informational purposes only and should not be considered as professional advice.</p>
            <ul>
                <li><strong>Financial Information:</strong> Not personalized financial advice. Consult a qualified financial advisor.</li>
                <li><strong>Legal Information:</strong> Not legal advice. Consult a licensed attorney for legal matters.</li>
                <li><strong>Business Valuations:</strong> Estimates only. Professional appraisal recommended for official purposes.</li>
                <li><strong>Tax Information:</strong> General guidance only. Consult a tax professional for specific situations.</li>
            </ul>
            <p>By continuing, you acknowledge that you understand these limitations and will seek appropriate professional consultation when needed.</p>
        </div>
        <div class="disclaimer-actions">
            <button id="disclaimerAccept" class="disclaimer-button primary">I Understand</button>
            <button id="disclaimerCancel" class="disclaimer-button secondary">Cancel</button>
        </div>
    </div>

    <!-- Agent Banner (initially hidden) -->
    <div id="agentBanner" class="agent-banner hidden">
        <div class="agent-banner-icon">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/>
            </svg>
        </div>
        <span id="agentBannerText">Active Agent</span>
    </div>    <!-- Main Container -->
    <div id="app" class="main-container">
        <!-- Modern ChatGPT-style Sidebar -->
        <div id="modernSidebar" class="modern-sidebar">
            <!-- Sidebar Header -->
            <div class="sidebar-header">
                <!-- New Chat Button -->
                <button id="newChatBtn" class="new-chat-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14M5 12h14"/>
                    </svg>
                    New Chat
                </button>

                <!-- Search Container -->
                <div class="search-container">
                    <input 
                        type="text" 
                        id="conversationSearch" 
                        class="search-input" 
                        placeholder="Search conversations..."
                    >
                    <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-4.35-4.35M17 10a7 7 0 11-14 0 7 7 0 0114 0z"/>
                    </svg>                </div>
            </div>            <!-- Magnifying Glass Image -->
            <div class="sidebar-image-container">
                <img src="/figma design exports/images/pose 3 magnifying glass no background 3.PNG" 
                     alt="Magnifying Glass" 
                     class="sidebar-magnifying-glass">
            </div>

            <!-- Conversation Sections -->
            <div class="conversation-sections">
                <!-- Pinned Conversations -->
                <div id="pinnedSection" class="conversation-section" style="display: none;">
                    <h3>Pinned</h3>
                    <div id="pinnedConversations" class="conversation-list">
                        <!-- Pinned conversations will be loaded here -->
                    </div>
                </div>

                <!-- Today -->
                <div id="todaySection" class="conversation-section" style="display: none;">
                    <h3>Today</h3>
                    <div id="todayConversations" class="conversation-list">
                        <!-- Today's conversations will be loaded here -->
                    </div>
                </div>

                <!-- Yesterday -->
                <div id="yesterdaySection" class="conversation-section" style="display: none;">
                    <h3>Yesterday</h3>
                    <div id="yesterdayConversations" class="conversation-list">
                        <!-- Yesterday's conversations will be loaded here -->
                    </div>
                </div>

                <!-- Last 7 Days -->
                <div id="last7DaysSection" class="conversation-section" style="display: none;">
                    <h3>Last 7 Days</h3>
                    <div id="last7DaysConversations" class="conversation-list">
                        <!-- Last 7 days conversations will be loaded here -->
                    </div>
                </div>

                <!-- Loading State -->
                <div id="conversationsLoading" class="loading-conversations">
                    Loading conversations...
                </div>

                <!-- Empty State -->
                <div id="conversationsEmpty" class="loading-conversations" style="display: none;">
                    No conversations yet. Start a new chat!
                </div>
            </div>
        </div>

        <!-- Mobile Sidebar Overlay -->
        <div id="sidebarOverlay" class="sidebar-overlay"></div>

        <!-- Main Content Area -->
        <div class="main-content" style="margin-left: 0;">            <!-- Collapsible Agent Status Panel -->
            <div id="agentStatusPanel" class="agent-status-panel-collapsed fixed top-4 right-4 z-20">
                <!-- Compact View -->                <div id="agentStatusCompact" class="agent-status-compact bg-white rounded-lg shadow-lg border border-gray-200 cursor-pointer">                    <div class="flex items-center p-3 gap-2">                        <div id="activeAgentIcon" class="active-agent-icon">
                            <img src="/figma%20design%20exports/images/3dicons-megaphone-dynamic-premium.png" alt="Orchestrator" width="24" height="24">
                        </div>
                        <div class="agent-info">
                            <div id="activeAgentName" class="text-sm font-medium text-gray-800">Orchestrator</div>
                            <div class="flex items-center gap-1">
                                <span id="activeAgentStatus" class="agent-status online"></span>
                                <span class="text-xs text-gray-500">Online</span>
                            </div>
                        </div>
                        <svg id="agentPanelToggle" class="w-4 h-4 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </div>
                </div>
                  <!-- Expanded View -->
                <div id="agentStatusExpanded" class="agent-status-expanded bg-white rounded-lg shadow-lg border border-gray-200 mt-2" style="display: none;">
                    <div class="p-4">
                        <h3 class="text-sm font-semibold text-gray-800 mb-3">A2A Agent Network</h3>
                        <div class="space-y-3">
                            <div class="agent-item" data-agent="orchestrator" data-tooltip="Coordinates all agents and routes your queries to the most suitable specialists. Acts as the central intelligence hub for complex multi-domain business inquiries.">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-2">
                                        <div class="agent-icon-3d" style="background-image: url('/figma%20design%20exports/images/3dicons-megaphone-dynamic-premium.png');"></div>
                                        <div>
                                            <div class="text-sm font-medium text-gray-800">Orchestrator</div>
                                            <div class="text-xs text-gray-500">Central coordination hub</div>
                                        </div>
                                    </div>                                    <div class="flex items-center gap-1">
                                        <span id="orchestratorStatus" class="agent-status status-online"></span>
                                        <span class="text-xs text-gray-600">Online</span>
                                    </div>
                                </div>
                            </div>
                            <div class="agent-item" data-agent="broker" data-tooltip="Provides business valuations, market analysis, and deal structuring advice. Specializes in UK business marketplace insights and comparable sales data.">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-2">
                                        <div class="agent-icon-3d" style="background-image: url('/figma%20design%20exports/images/3dicons-calculator-dynamic-premium.png');"></div>
                                        <div>
                                            <div class="text-sm font-medium text-gray-800">Broker Agent</div>
                                            <div class="text-xs text-gray-500">Business valuations & market analysis</div>
                                        </div>
                                    </div>                                    <div class="flex items-center gap-1">
                                        <span id="brokerStatus" class="agent-status status-online"></span>
                                        <span class="text-xs text-gray-600">Online</span>
                                    </div>
                                </div>
                            </div>
                            <div class="agent-item" data-agent="legal" data-tooltip="Handles contracts, NDAs, compliance checks, and regulatory guidance. Provides legal document generation and due diligence support for business transactions.">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-2">
                                        <div class="agent-icon-3d" style="background-image: url('/figma%20design%20exports/images/3dicons-folder-dynamic-premium.png');"></div>
                                        <div>
                                            <div class="text-sm font-medium text-gray-800">Legal Agent</div>
                                            <div class="text-xs text-gray-500">Contracts, NDAs & compliance</div>
                                        </div>
                                    </div>                                    <div class="flex items-center gap-1">
                                        <span id="legalStatus" class="agent-status status-online"></span>
                                        <span class="text-xs text-gray-600">Online</span>
                                    </div>
                                </div>
                            </div>
                            <div class="agent-item" data-agent="finance" data-tooltip="Offers EBITDA valuations, tax scenario analysis, and financial due diligence guidance. Specializes in UK business finance and deal structuring from a financial perspective.">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-2">
                                        <div class="agent-icon-3d" style="background-image: url('/figma%20design%20exports/images/3dicons-pound-dynamic-premium.png');"></div>
                                        <div>
                                            <div class="text-sm font-medium text-gray-800">Finance Agent</div>
                                            <div class="text-xs text-gray-500">EBITDA analysis & tax scenarios</div>
                                        </div>
                                    </div>                                    <div class="flex items-center gap-1">
                                        <span id="financeStatus" class="agent-status status-online"></span>
                                        <span class="text-xs text-gray-600">Online</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div><!-- Content Header -->
    <div class="content-header">
      <div class="flex items-center">
        <!-- Mobile Menu Button -->
        <button id="mobileSidebarToggle" class="mobile-sidebar-toggle lg:hidden p-2 hover:bg-gray-100 rounded-lg transition-all duration-200 mr-3" title="Open Menu">
          <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
          </svg>
        </button>        <div class="flex items-center space-x-2">
          <div class="arzani-header">
            <span class="arzani-text">Arzani</span>
            <span class="arzani-x">X</span>
          </div>
        </div>
        
        <!-- Enhanced Chat Context Header -->
        <div id="chatContextHeader" class="chat-context-header" style="display: none;">
          <div class="flex items-center gap-3">
            <div class="conversation-context">
              <h1 id="activeConversationTitle" class="conversation-title-main">New Conversation</h1>
              <div class="conversation-subtitle-main">
                <span id="activeConversationAgent">Orchestrator</span>
                <span class="separator">‚Ä¢</span>
                <span id="activeConversationTime">Just started</span>
                <span class="separator">‚Ä¢</span>
                <span id="activeConversationMessages">0 messages</span>
              </div>
            </div>
          </div>
        </div></div><div class="flex items-center space-x-3">
        <button class="p-2 hover:bg-gray-100 rounded-lg transition-all duration-200 mobile-hidden" title="Quick Actions">
          <svg class="w-5 h-5 text-gray-600" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
          </svg>
        </button>
        <button class="p-2 hover:bg-gray-100 rounded-lg transition-all duration-200 mobile-hidden" title="Export Chat">
          <svg class="w-5 h-5 text-gray-600" fill="currentColor" viewBox="0 0 24 24">
            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
          </svg>
        </button>
        <button class="p-2 hover:bg-gray-100 rounded-lg transition-all duration-200 mobile-hidden" title="Settings">
          <svg class="w-5 h-5 text-gray-600" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
          </svg>
        </button>
      </div>
    </div>
    
    <!-- Main Content Body -->
    <div class="content-body">        <!-- Conversation Area - Hidden initially -->
        <div id="conversationArea" class="conversation-area hidden w-full h-full">
          <div class="bg-white h-full flex flex-col">
            <!-- A2A Status Header -->
            
              <div class="flex items-center space-x-4">
                <!-- Task Progress Indicator -->
                <div id="taskProgressPanel" class="task-progress-panel hidden">
                  <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                    <span class="text-sm text-gray-600" id="taskProgressText">Processing task...</span>
                    <div class="text-xs text-gray-400" id="taskProgressPercentage">0%</div>
                  
                </div>
                
                <!-- Agent Status Indicator -->
                <div id="agentStatusPanel" class="agent-status-panel flex items-center space-x-2">
                  <div class="flex items-center space-x-1">
                    <div class="w-2 h-2 bg-green-500 rounded-full" id="agentStatusIndicator"></div>
                    <span class="text-xs text-gray-500" id="agentStatusText">Ready</span>
                  </div>
                </div>

                <!-- Session Context Indicator -->
                <div id="sessionContextPanel" class="session-context-panel hidden">
                  <div class="flex items-center space-x-1">
                    <svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                    </svg>
                    <span class="text-xs text-gray-500" id="sessionContextText">Context active</span>
                  </div>
                </div>
              </div>

              <div class="flex items-center space-x-2">
                <!-- File Upload Status -->
                <div id="fileUploadPanel" class="file-upload-panel hidden">
                  <div class="flex items-center space-x-2">
                    <svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/>
                    </svg>
                    <span class="text-xs text-gray-500" id="fileUploadText">Files ready</span>
                  </div>
                </div>

                <!-- Clear Conversation Button -->
                <button id="clearConversationButton" class="text-gray-400 hover:text-gray-600 transition-colors">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H8a1 1 0 00-1 1v3M4 7h16"/>
                  </svg>
                </button>
              </div>
            </div>

            <!-- A2A Agent Transition Banner -->
            <div id="agentTransitionBanner" class="agent-transition-banner hidden bg-gradient-to-r from-blue-50 to-indigo-50 border-l-4 border-blue-500 p-3">
              <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                  <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 bg-blue-500 rounded-full animate-bounce"></div>
                    <span class="text-sm font-medium text-blue-700" id="agentTransitionText">Transitioning to Legal Agent...</span>
                  </div>
                </div>
                <button id="dismissTransitionBanner" class="text-blue-400 hover:text-blue-600 transition-colors">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                  </svg>
                </button>
              </div>
            </div>            <!-- Messages Container -->
            <div id="messagesContainer" class="messages-container flex-1 overflow-y-auto space-y-4 py-6">
              <!-- Scroll to Bottom Button -->
              <div id="scrollToBottomBtn" class="scroll-to-bottom-btn hidden">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
                </svg>
              </div>
              
              <!-- A2A Active Tasks Panel -->
              <div id="activeTasksPanel" class="active-tasks-panel hidden bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                <div class="flex items-center justify-between mb-3">
                  <h3 class="text-sm font-medium text-blue-700 flex items-center">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                    </svg>
                    Active A2A Tasks
                  </h3>
                  <button id="minimizeTasksPanel" class="text-blue-500 hover:text-blue-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
                    </svg>
                  </button>
                </div>
                <div id="activeTasksList" class="space-y-2">
                  <!-- Tasks will be populated dynamically -->
                </div>
              </div>

              <!-- A2A File Uploads Panel -->
              <div id="fileUploadsPanel" class="file-uploads-panel hidden bg-green-50 border border-green-200 rounded-lg p-4 mb-4">
                <div class="flex items-center justify-between mb-3">
                  <h3 class="text-sm font-medium text-green-700 flex items-center">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/>
                    </svg>
                    A2A File Uploads
                  </h3>
                  <button id="minimizeFileUploadsPanel" class="text-green-500 hover:text-green-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
                    </svg>
                  </button>
                </div>
                <div id="fileUploadsList" class="space-y-2">
                  <!-- File uploads will be populated dynamically -->
                </div>
              </div>

              <!-- A2A Agent Interactions Panel -->
              <div id="agentInteractionsPanel" class="agent-interactions-panel hidden bg-purple-50 border border-purple-200 rounded-lg p-4 mb-4">
                <div class="flex items-center justify-between mb-3">
                  <h3 class="text-sm font-medium text-purple-700 flex items-center">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8h2a2 2 0 012 2v6a2 2 0 01-2 2h-2v4l-4-4H9a1.994 1.994 0 01-1.414-.586m0 0L11 14h4a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2v4l.586-.586z"/>
                    </svg>
                    Agent Performance
                  </h3>
                  <button id="minimizeAgentInteractionsPanel" class="text-purple-500 hover:text-purple-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
                    </svg>
                  </button>
                </div>
                <div id="agentInteractionsList" class="space-y-2">
                  <!-- Agent interactions will be populated dynamically -->
                </div>
              </div>              <!-- Welcome message -->
              <div class="message-group ai-message">
                <div class="message-bubble">
                  <p>Hello! I'm Arzani, your AI business marketplace assistant. I can help you with business valuations, finding listings, legal advice, and financial guidance. What would you like to know?</p>
                </div>
              </div>
            </div>
          </div>
        </div>        <!-- Main Heading -->
        <div id="mainHeading" class="text-center mb-8">
          <h1 class="text-2xl md:text-3xl lg:text-4xl font-normal text-black leading-tight tracking-tight">
            <span id="mainHeadingText">What's on the agenda today?</span>
          </h1>
        </div>
          <!-- Main Form Container -->
        <div id="mainFormContainer" class="w-full max-w-4xl mx-auto">
          <div class="form-container bg-white p-6 md:p-8">            <div class="relative">
              <textarea id="mainChatInput" placeholder="Ask anything" rows="1"
                     class="w-full min-h-12 max-h-40 px-6 py-3 text-base font-normal border border-gray-300 rounded-3xl outline-none bg-white text-black placeholder-gray-400 pr-32 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 resize-none overflow-hidden"></textarea>
              
              <div class="absolute right-2 top-1/2 transform -translate-y-1/2 flex items-center space-x-2">
                <!-- File Upload Button -->
                <button id="fileButton" class="w-9 h-9 hover:bg-gray-100 rounded-full transition-colors flex items-center justify-center">
                  <svg class="w-5 h-5 text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                  </svg>
                </button>
                
                <!-- Voice/Dictate Button -->
                <button id="voiceButton" class="w-9 h-9 hover:bg-gray-100 rounded-full transition-colors flex items-center justify-center mobile-hidden">
                  <svg class="w-5 h-5 text-gray-800" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"/>
                  </svg>
                </button>
                  <!-- Submit/Stop Button -->
                <button id="submitButton" class="w-9 h-9 bg-black rounded-full hover:bg-gray-800 transition-colors flex items-center justify-center">
                  <svg id="submitButtonIcon" class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                  </svg>
                  <svg id="stopButtonIcon" class="w-5 h-5 text-white hidden" fill="currentColor" viewBox="0 0 24 24">
                    <rect x="6" y="6" width="12" height="12" rx="2"/>
                  </svg>
                </button></div>
            </div>
          </div>
        </div>          <!-- Bottom Input Area - Hidden initially, shown after first message -->        <div id="bottomInputArea" class="bottom-input-area hidden fixed bottom-0 left-0 right-0 z-40">
            <div class="w-full max-w-4xl mx-auto">
                <div class="flex items-center space-x-3 p-4 md:p-6">
                    <div class="flex-1 relative"><textarea id="bottomChatInput" placeholder="Continue the conversation..." rows="1"
                       class="w-full min-h-12 max-h-40 px-6 py-3 text-base font-normal border-0 rounded-3xl outline-none bg-white/90 backdrop-blur-md text-black placeholder-gray-400 pr-32 focus:bg-white/95 focus:ring-2 focus:ring-blue-500/50 resize-none overflow-hidden shadow-lg transition-all duration-300"></textarea>
                
                <div class="absolute right-2 top-1/2 transform -translate-y-1/2 flex items-center space-x-2">
                  <!-- File Upload Button -->
                  <button id="bottomFileButton" class="w-9 h-9 hover:bg-gray-100 rounded-full transition-colors flex items-center justify-center">
                    <svg class="w-5 h-5 text-gray-800" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                    </svg>
                  </button>
                    <!-- Submit/Stop Button -->
                  <button id="bottomSubmitButton" class="w-9 h-9 bg-black rounded-full hover:bg-gray-800 transition-colors flex items-center justify-center">
                    <svg id="bottomSubmitButtonIcon" class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                    </svg>
                    <svg id="bottomStopButtonIcon" class="w-5 h-5 text-white hidden" fill="currentColor" viewBox="0 0 24 24">
                      <rect x="6" y="6" width="12" height="12" rx="2"/>
                    </svg>                  </button>                </div>
              </div>
                </div>
            </div>
        </div>
    </div><!-- JavaScript for A2A Integration and UI Functionality -->
<script>
class ArzaniA2AClient {  constructor() {
    this.orchestratorUrl = 'http://localhost:5001';
    this.agentUrls = {
      orchestrator: 'http://localhost:5001',
      broker: 'http://localhost:5002',
      legal: 'http://localhost:5003',      finance: 'http://localhost:5004'
    };    this.isProcessing = false;
    this.chatHistory = [];
    this.selectedAgent = 'orchestrator';    this.agentStatus = {
      orchestrator: 'online',
      broker: 'online', 
      legal: 'online',
      finance: 'online'
    };
    this.conversationStarted = false;
    this.credits = 30;
    this.disclaimerShown = false;
      // Global conversation creation mutex to prevent duplicate conversations
    this.isCreatingConversationGlobal = false;
    this.conversationCreationPromise = null;
    
    // ThinkingPanel tracking
    this.currentThinkingPanel = null;
    this.currentThinkingMessageId = null;
    
    // Agent thinking animation (legacy - may be removed in future)
    this.agentThinkingAnimation = null;
    
    // Stop functionality
    this.currentTypewriterAbort = null;
    this.shouldStopProcessing = false;
    this.animationTimeouts = [];    // Animation control
    this.isLoadingHistory = false;
    this.animatedMessages = new Set(); // Track which messages have been animated    this.isInitialPageLoad = true; // Track if this is the first page load
      // Sidebar synchronization timeout
    this.sidebarRefreshTimeout = null;
    
    // Sequential Agent Delegation System
    this.activeAgent = null;
    this.currentAgentSection = null;
    this.agentSections = [];
    this.agentBanner = null;
    this.agentBannerText = null;
    
    // Agent color schemes for theming
    this.agentColors = {
      orchestrator: { primary: '#3B82F6', light: '#EFF6FF', border: '#DBEAFE' },
      broker: { primary: '#10B981', light: '#ECFDF5', border: '#D1FAE5' },
      legal: { primary: '#F59E0B', light: '#FFFBEB', border: '#FED7AA' },
      finance: { primary: '#8B5CF6', light: '#F5F3FF', border: '#E9D5FF' }
    };
    
    // Scroll to bottom functionality
    this.scrollToBottomManager = null;
    
    // ThinkingPanel tracking
    this.currentThinkingPanel = null;
    this.currentThinkingMessageId = null;
    
    this.initializeUI();
    this.startHealthCheck();
    this.initializePersistence();
  }
  // Initialize persistence manager with sidebar integration
  async initializePersistence() {
    try {
      // Get auth token
      const token = localStorage.getItem('authToken') || 
                    document.querySelector('meta[name="auth-token"]')?.content ||
                    localStorage.getItem('token');
      
      if (token && window.arzaniPersistence) {
        window.arzaniPersistence.setAuthToken(token);
        
        // Store reference to persistence manager
        this.persistenceManager = window.arzaniPersistence;
        
        // Setup real-time updates for sidebar synchronization
        this.persistenceManager.setupRealTimeUpdates();
        
        console.log('‚úÖ Persistence manager initialized with sidebar integration');
      } else {
        console.warn('‚ö†Ô∏è No auth token found or persistence manager not available');
      }
    } catch (error) {
      console.error('‚ùå Failed to initialize persistence:', error);
    }  }initializeUI() {
    // Get UI elements using the new IDs
    this.input = document.getElementById('mainChatInput');
    this.submitButton = document.getElementById('submitButton');
    this.voiceButton = document.getElementById('voiceButton');
    this.fileButton = document.getElementById('fileButton');
    
    // Initialize agent thinking animation
    this.agentThinkingAnimation = new AgentThinkingAnimation();
      // New conversational layout elements
    this.conversationArea = document.getElementById('conversationArea');
    this.messagesContainer = document.getElementById('messagesContainer');
    this.mainHeading = document.getElementById('mainHeading');
    this.mainHeadingText = document.getElementById('mainHeadingText');
    this.mainFormContainer = document.getElementById('mainFormContainer');
    this.bottomInputArea = document.getElementById('bottomInputArea');
    this.bottomChatInput = document.getElementById('bottomChatInput');
    this.bottomSubmitButton = document.getElementById('bottomSubmitButton');
    this.bottomFileButton = document.getElementById('bottomFileButton');
    this.clearConversationButton = document.getElementById('clearConversationButton');
    this.creditsRemaining = document.getElementById('creditsRemaining');
    
    // Sequential Agent Delegation System elements
    this.agentBanner = document.getElementById('agentBanner');
    this.agentBannerText = document.getElementById('agentBannerText');
    
    // Bind event listeners
    this.bindEvents();
    
    // Initialize agent status indicators
    this.initializeAgentStatus();
    
    // Initialize keyboard shortcuts
    this.initializeKeyboardShortcuts();
      // Set initial agent UI
    this.updateSelectedAgentUI();
      // Initialize textarea auto-resize
    if (this.input) {
      this.autoResizeTextarea(this.input);
    }
    if (this.bottomChatInput) {
      this.autoResizeTextarea(this.bottomChatInput);
    }
    
    // Initialize rotating phrases for main heading
    this.initializeRotatingPhrases();
    
    // Initialize scroll to bottom functionality if available
    this.initializeScrollToBottom();
  }
  
  // Initialize scroll to bottom functionality
  initializeScrollToBottom() {
    // We'll use our existing class if available, otherwise create a simple implementation
    if (window.scrollToBottomManager) {
      this.scrollToBottomManager = window.scrollToBottomManager;
      console.log('‚úÖ Using external ScrollToBottomManager');
    } else {
      // Simple fallback implementation if the external script fails to load
      const scrollBtn = document.getElementById('scrollToBottomBtn');
      const messagesContainer = this.messagesContainer;
      
      if (scrollBtn && messagesContainer) {
        // Show button when scrolling up
        messagesContainer.addEventListener('scroll', () => {
          const isNearBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 100;
          
          if (!isNearBottom) {
            scrollBtn.classList.remove('hidden');
            scrollBtn.classList.add('visible');
          } else {
            scrollBtn.classList.add('hidden');
            scrollBtn.classList.remove('visible');
          }
        });
        
        // Scroll to bottom on click
        scrollBtn.addEventListener('click', () => {
          messagesContainer.scrollTo({
            top: messagesContainer.scrollHeight,
            behavior: 'smooth'
          });
        });
        
        console.log('‚úÖ Using simple ScrollToBottomManager fallback');
      }
    }
  }

  // Helper method to escape HTML
  escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  bindEvents() {
    // Auto-resize functionality for main chat input
    this.input.addEventListener('input', () => {
      this.autoResizeTextarea(this.input);
    });
      // Submit on Enter key or button click for main input
    this.input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !this.isProcessing && !this.isCreatingConversationGlobal) {
        e.preventDefault();
        this.handleUserMessage();
      }
    });

    this.submitButton.addEventListener('click', () => {
      if (this.isProcessing) {
        this.stopProcessing();
      } else if (!this.isCreatingConversationGlobal) {
        this.handleUserMessage();
      }
    });    // Bottom input area handlers
    this.bottomChatInput.addEventListener('input', () => {
      this.autoResizeTextarea(this.bottomChatInput);
    });
    
    this.bottomChatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !this.isProcessing && !this.isCreatingConversationGlobal) {
        e.preventDefault();
        this.handleBottomUserMessage();
      }
    });

    this.bottomSubmitButton.addEventListener('click', () => {
      if (this.isProcessing) {
        this.stopProcessing();
      } else if (!this.isCreatingConversationGlobal) {
        this.handleBottomUserMessage();
      }
    });// Clear conversation button
    this.clearConversationButton.addEventListener('click', () => {
      this.clearConversation();
    });

    // Stop button event listeners - these handle the actual stop button icons
    const stopButtonIcon = document.getElementById('stopButtonIcon');
    const bottomStopButtonIcon = document.getElementById('bottomStopButtonIcon');
    
    if (stopButtonIcon) {
      stopButtonIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('üõë Stop button icon clicked (main)');
        this.stopProcessing();
      });
    }
    
    if (bottomStopButtonIcon) {
      bottomStopButtonIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('üõë Stop button icon clicked (bottom)');
        this.stopProcessing();
      });
    }    // File upload handlers
    this.fileButton.addEventListener('click', () => {
      this.triggerFileInput();
    });

    this.bottomFileButton.addEventListener('click', () => {
      this.triggerFileInput();
    });

    // Create hidden file input for uploads
    this.createFileInput();

    // Sidebar navigation handlers
    this.setupSidebarNavigation();    // Voice button 
    this.voiceButton.addEventListener('click', () => {
      this.handleVoiceInput();
    });

    // Conversation search functionality
    this.setupConversationSearch();

    // Disclaimer popup handlers
    const disclaimerAccept = document.getElementById('disclaimerAccept');
    const disclaimerCancel = document.getElementById('disclaimerCancel');
    const disclaimerClose = document.getElementById('disclaimerClose');

    if (disclaimerAccept) {
      disclaimerAccept.addEventListener('click', () => {
        this.acceptDisclaimer();
      });
    }

    if (disclaimerCancel) {
      disclaimerCancel.addEventListener('click', () => {
        this.cancelDisclaimer();
      });
    }

    if (disclaimerClose) {
      disclaimerClose.addEventListener('click', () => {
        this.cancelDisclaimer();
      });    }
  }
  // Auto-resize textarea to fit content
  autoResizeTextarea(textarea) {
    // If textarea is empty, reset to minimum height
    if (!textarea.value.trim()) {
      const minHeight = 48; // 3rem equivalent to min-h-12
      textarea.style.height = minHeight + 'px';
      textarea.style.overflowY = 'hidden';
      textarea.setAttribute('data-expanded', 'false');
      return;
    }
    
    // Reset height to auto to get accurate scrollHeight
    textarea.style.height = 'auto';
    
    // Calculate the required height
    const scrollHeight = textarea.scrollHeight;
    const maxHeight = parseInt(window.getComputedStyle(textarea).maxHeight);
    const minHeight = 48; // 3rem equivalent to min-h-12
    
    // Determine if textarea is expanded (more than one line)
    const isExpanded = scrollHeight > minHeight;
    
    // Set the height to fit content, respecting max-height
    if (scrollHeight <= maxHeight) {
      textarea.style.height = Math.max(scrollHeight, minHeight) + 'px';
      textarea.style.overflowY = 'hidden';
    } else {
      textarea.style.height = maxHeight + 'px';
      textarea.style.overflowY = 'auto';
    }      // Update expanded state for CSS styling
    textarea.setAttribute('data-expanded', isExpanded.toString());
  }
  // Reset textarea to original height after message is sent
  resetTextareaHeight(textarea) {
    const minHeight = 48; // 3rem equivalent to min-h-12
    textarea.style.height = minHeight + 'px';
    textarea.style.overflowY = 'hidden';
    textarea.setAttribute('data-expanded', 'false');
    console.log('Textarea reset to height:', minHeight + 'px');
  }

  // Setup conversation search functionality
  setupConversationSearch() {
    const searchInput = document.getElementById('conversationSearch');
    if (!searchInput) {
      console.warn('Conversation search input not found');
      return;
    }

    let searchTimeout = null;
    
    // Handle search input with debouncing
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      // Clear previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }
      
      // Debounce search by 300ms
      searchTimeout = setTimeout(() => {
        if (query.length === 0) {
          this.clearSearch();
        } else if (query.length >= 2) {
          this.performConversationSearch(query);
        }
      }, 300);
    });
    
    // Handle Enter key for immediate search
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const query = e.target.value.trim();
        if (query.length >= 2) {
          this.performConversationSearch(query);
        }
      }
    });
    
    // Clear search on escape
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        e.target.value = '';
        this.clearSearch();
      }
    });
  }
  // Perform conversation search
  async performConversationSearch(query) {
    try {
      console.log('üîç Searching conversations for:', query);
      
      // Show loading state
      this.showSearchLoading();
      
      // Get auth token with multiple fallback methods
      const token = this.getAuthToken();
      
      if (!token) {
        console.error('No auth token found for search');
        this.showSearchError('Authentication required');
        return;
      }
      
      // Make API call to search conversations
      const response = await fetch(`/api/threads/search?q=${encodeURIComponent(query)}&limit=20`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Search failed: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.success) {
        this.displaySearchResults(data.data, query);
      } else {
        this.showSearchError('Search failed');
      }
      
    } catch (error) {
      console.error('‚ùå Conversation search error:', error);
      this.showSearchError('Search failed');
    }
  }

  // Display search results
  displaySearchResults(searchData, query) {
    const conversations = searchData.conversations || [];
    console.log(`üîç Found ${conversations.length} conversations for "${query}"`);
    
    // Hide all normal sections
    this.hideAllConversationSections();
    
    // Show or create search results section
    this.showSearchResultsSection(conversations, query);
  }

  // Show search loading state
  showSearchLoading() {
    const searchSection = this.getOrCreateSearchSection();
    searchSection.innerHTML = `
      <div class="search-loading">
        <div class="loading-spinner"></div>
        <span>Searching conversations...</span>
      </div>
    `;
    searchSection.style.display = 'block';
  }

  // Show search error
  showSearchError(message) {
    const searchSection = this.getOrCreateSearchSection();
    searchSection.innerHTML = `
      <div class="search-error">
        <svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span>${message}</span>
      </div>
    `;
    searchSection.style.display = 'block';
  }

  // Get or create search results section
  getOrCreateSearchSection() {
    let searchSection = document.getElementById('searchResultsSection');
    if (!searchSection) {
      const conversationSections = document.querySelector('.conversation-sections');
      if (conversationSections) {
        searchSection = document.createElement('div');
        searchSection.id = 'searchResultsSection';
        searchSection.className = 'conversation-section search-results-section';
        conversationSections.insertBefore(searchSection, conversationSections.firstChild);
      }
    }
    return searchSection;
  }

  // Show search results section
  showSearchResultsSection(conversations, query) {
    const searchSection = this.getOrCreateSearchSection();
    
    if (conversations.length === 0) {
      searchSection.innerHTML = `
        <div class="section-header">
          <h3>Search Results</h3>
          <span class="section-count">0</span>
        </div>
        <div class="search-no-results">
          <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M21 21l-4.35-4.35M17 10a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
          <span>No conversations found for "${query}"</span>
        </div>
      `;
    } else {
      const conversationItems = conversations.map(conv => this.createSearchResultItem(conv, query)).join('');
      searchSection.innerHTML = `
        <div class="section-header">
          <h3>Search Results</h3>
          <span class="section-count">${conversations.length}</span>
        </div>
        <div class="conversation-list">
          ${conversationItems}
        </div>
      `;
    }
    
    searchSection.style.display = 'block';
  }
  // Create search result item HTML
  createSearchResultItem(conversation, query) {
    const timeAgo = this.formatTimeAgo(new Date(conversation.last_message_time || conversation.updated_at));
    const avatarIcon = this.getAgentAvatarIcon(conversation.agent_type || 'orchestrator');
    const title = conversation.group_name || conversation.title || 'Untitled Chat';
    const lastMessage = conversation.last_message || 'No messages yet';
    
    // Highlight search terms in title and message
    const highlightedTitle = this.highlightSearchTerms(title, query);
    const highlightedMessage = this.highlightSearchTerms(lastMessage, query);
    
    return `
      <div class="conversation-item search-result" 
           data-conversation-id="${conversation.id}" 
           onclick="window.loadConversationFromSearch(${conversation.id})"
           style="cursor: pointer;">
        <div class="conversation-avatar">
          ${avatarIcon}
        </div>
        <div class="conversation-content">
          <div class="conversation-header">
            <h4 class="conversation-title">${highlightedTitle}</h4>
            <span class="conversation-time">${timeAgo}</span>
          </div>
          <p class="conversation-preview">${highlightedMessage}</p>
          ${conversation.participants ? `<div class="conversation-participants">${conversation.participants}</div>` : ''}
          ${conversation.agent_type ? `<div class="conversation-agent">Agent: ${conversation.agent_type}</div>` : ''}
        </div>
      </div>
    `;
  }

  // Highlight search terms in text
  highlightSearchTerms(text, query) {
    if (!text || !query) return text;
    
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  // Get agent avatar icon
  getAgentAvatarIcon(agentType) {
    const icons = {
      orchestrator: '<svg class="agent-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>',
      finance: '<svg class="agent-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M7 14c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zM20 13.09L19.09 12l.91-.91c.39-.39.39-1.02 0-1.41L18.59 8.27c-.39-.39-1.02-.39-1.41 0L16.27 9.18l-1.18-1.18L16 7.09c.39-.39.39-1.02 0-1.41l-1.41-1.41c-.39-.39-1.02-.39-1.41 0L12.27 5.18 11.09 4l.91-.91c.39-.39.39-1.02 0-1.41L10.59.27c-.39-.39-1.02-.39-1.41 0L8.27 1.18 7.09 0 6.18.91c-.39.39-.39 1.02 0 1.41L7.09 3.32 5.91 4.5 4.5 3.09c-.39-.39-1.02-.39-1.41 0L1.68 4.5c-.39.39-.39 1.02 0 1.41L3.09 7.32 2.18 8.23c-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l.91-.91 1.18 1.18-.91.91c-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l.91-.91L10.18 16l-.91.91c-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l.91-.91L14.18 20l-.91.91c-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l.91-.91L17.91 24l.91-.91c.39-.39.39-1.02 0-1.41L17.91 20.68l1.18-1.18 1.41 1.41c.39.39 1.02.39 1.41 0l1.41-1.41c.39-.39.39-1.02 0-1.41L21.91 16.68l.91-.91c.39-.39.39-1.02 0-1.41L21.41 13.09c-.39-.39-1.02-.39-1.41 0L20 13.09z"/></svg>',
      legal: '<svg class="agent-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2h-4zM10 4h4v2h-4V4zm8 15H6V10h12v9z"/></svg>',
      broker: '<svg class="agent-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>'
    };
    return icons[agentType] || icons.orchestrator;
  }

  // Clear search and show normal conversations
  clearSearch() {
    console.log('üîç Clearing search');
    
    // Hide search results section
    const searchSection = document.getElementById('searchResultsSection');
    if (searchSection) {
      searchSection.style.display = 'none';
    }
    
    // Show normal conversation sections
    this.showAllConversationSections();
  }

  // Hide all conversation sections
  hideAllConversationSections() {
    const sections = ['pinnedSection', 'todaySection', 'yesterdaySection', 'last7DaysSection', 'olderSection'];
    sections.forEach(sectionId => {
      const section = document.getElementById(sectionId);
      if (section) {
        section.style.display = 'none';
      }
    });
  }

  // Show all conversation sections
  showAllConversationSections() {
    const sections = ['pinnedSection', 'todaySection', 'yesterdaySection', 'last7DaysSection', 'olderSection'];
    sections.forEach(sectionId => {
      const section = document.getElementById(sectionId);
      if (section && section.children.length > 0) {
        // Only show sections that have content
        const conversationList = section.querySelector('.conversation-list');
        if (conversationList && conversationList.children.length > 0) {
          section.style.display = 'block';
        }
      }
    });
  }  // Load conversation from search results
  async loadConversationFromSearch(conversationId) {
    try {
      console.log('üîç Loading conversation from search:', conversationId);
      
      // Clear search first
      const searchInput = document.getElementById('conversationSearch');
      if (searchInput) {
        searchInput.value = '';
      }
      this.clearSearch();
      
      // Ensure transition to conversation mode first
      this.forceTransitionToConversationLayout();
      
      // Load the conversation using multiple fallback methods
      if (window.arzaniModernSidebar && typeof window.arzaniModernSidebar.selectConversation === 'function') {
        await window.arzaniModernSidebar.selectConversation(conversationId);
      } else if (this.persistenceManager && typeof this.persistenceManager.loadConversation === 'function') {
        await this.persistenceManager.loadConversation(conversationId);
      } else {
        // Direct conversation loading fallback
        await this.loadConversationById(conversationId);
      }
      
    } catch (error) {
      console.error('‚ùå Error loading conversation from search:', error);
      // Show user-friendly error
      this.showSearchError('Failed to load conversation');
    }
  }

  // Format time ago (helper method)
  formatTimeAgo(date) {
    const now = new Date();
    const diffInSeconds = Math.floor((now - date) / 1000);
    
    if (diffInSeconds < 60) return 'Just now';
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
    if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}d ago`;
    
    return date.toLocaleDateString();
  }
  
  // Initialize rotating phrases for main heading
  initializeRotatingPhrases() {
    const phrases = [
      "What's on the agenda today?",
      "What are you working on?",
      "How can I help you today?",
      "What's your next big idea?",
      "Ready to tackle some challenges?",
      "What would you like to explore?"
    ];
    
    if (this.mainHeadingText) {
      // Get a stored phrase index or generate a new one
      let phraseIndex = localStorage.getItem('arzaniPhraseIndex');
      
      if (phraseIndex === null) {
        // First visit - use random phrase
        phraseIndex = Math.floor(Math.random() * phrases.length);
      } else {
        // Rotate to next phrase
        phraseIndex = (parseInt(phraseIndex) + 1) % phrases.length;
      }
      
      // Store the current phrase index for next visit
      localStorage.setItem('arzaniPhraseIndex', phraseIndex.toString());
      
      // Update the heading text
      this.mainHeadingText.textContent = phrases[phraseIndex];
    }
  }
    // Enhanced stop processing functionality with complete animation orchestration
  stopProcessing() {
    console.log('üõë Stop processing initiated by user');
    
    // Set global stop flags FIRST
    this.shouldStopProcessing = true;
    this.isProcessing = false;
      // Remove ThinkingPanel if it exists
    if (this.currentThinkingPanel) {
      this.currentThinkingPanel.remove();
      this.currentThinkingPanel = null;
    }
    if (this.currentThinkingMessageId) {
      const thinkingContainer = document.getElementById(this.currentThinkingMessageId);
      if (thinkingContainer) {
        thinkingContainer.remove();
      }
      this.currentThinkingMessageId = null;
    }
    
    // Clear any pending timeouts that might be related to animations
    this.clearAnimationTimeouts();
      // Stop ALL typewriter animations at current position (don't complete the text)
    if (this.currentTypewriterAbort) {
      console.log('üõë Stopping typewriter animation at current position');
      // Call the abort function to stop the animation gracefully
      this.currentTypewriterAbort();
      this.currentTypewriterAbort = null;
    }
    
    // Stop any ongoing loading animations
    this.stopAllLoadingAnimations();
    
    // Update button states immediately
    this.updateButtonStates();
    
    // Remove any current loading messages
    this.removeAllLoadingMessages();
    
    // Add stop message to conversation
    this.addConversationMessage('‚èπÔ∏è Processing stopped by user. You can continue the conversation by adding more context.', 'assistant');
    
    console.log('‚úÖ Processing fully stopped - all animations halted');
  }
  
  // Stop all loading animations and indicators
  stopAllLoadingAnimations() {
    // Remove typing indicators
    const typingIndicators = document.querySelectorAll('.loading-dots, .typing-indicator');
    typingIndicators.forEach(indicator => {
      if (indicator.parentElement) {
        indicator.parentElement.remove();
      }
    });
      // Stop any CSS animations on message elements
    const animatedElements = document.querySelectorAll('.typewriter-text, .typewriter-cursor');
    animatedElements.forEach(element => {
      element.style.animation = 'none';
      element.style.transition = 'none';
      // Remove cursor elements completely
      if (element.classList.contains('typewriter-cursor')) {
        element.remove();
      }
    });
  }
  
  // Clear any animation-related timeouts
  clearAnimationTimeouts() {
    // Clear any timeouts that might be stored in the instance
    if (this.animationTimeouts) {
      this.animationTimeouts.forEach(timeout => clearTimeout(timeout));
      this.animationTimeouts = [];
    }
  }
  
  // Remove all loading messages from the conversation
  removeAllLoadingMessages() {
    const loadingMessages = document.querySelectorAll('[id^="conv-msg-"], [id^="agent-msg-"]');
    loadingMessages.forEach(message => {
      const loadingDots = message.querySelector('.loading-dots');
      if (loadingDots) {
        message.remove();
      }
    });
  }
  
  // Update button states between send/stop with animation awareness
  updateButtonStates(forceShowStop = false) {
    const submitIcon = document.getElementById('submitButtonIcon');
    const stopIcon = document.getElementById('stopButtonIcon');
    const bottomSubmitIcon = document.getElementById('bottomSubmitButtonIcon');
    const bottomStopIcon = document.getElementById('bottomStopButtonIcon');
    
    // If we're processing OR have an active typewriter animation, show stop button
    const shouldShowStop = this.isProcessing || this.currentTypewriterAbort !== null || forceShowStop;
    
    console.log('üîò Button state check:', {
      isProcessing: this.isProcessing,
      hasTypewriterAbort: this.currentTypewriterAbort !== null,
      forceShowStop: forceShowStop,
      shouldShowStop: shouldShowStop
    });
    
    if (shouldShowStop) {
      // Show stop buttons
      if (submitIcon) submitIcon.classList.add('hidden');
      if (stopIcon) stopIcon.classList.remove('hidden');
      if (bottomSubmitIcon) bottomSubmitIcon.classList.add('hidden');
      if (bottomStopIcon) bottomStopIcon.classList.remove('hidden');
    } else {
      // Show send buttons
      if (submitIcon) submitIcon.classList.remove('hidden');
      if (stopIcon) stopIcon.classList.add('hidden');
      if (bottomSubmitIcon) bottomSubmitIcon.classList.remove('hidden');
      if (bottomStopIcon) bottomStopIcon.classList.add('hidden');    }  }

  // ===== CENTRALIZED CONVERSATION CREATION =====  // This method ensures only one conversation can be created at a time globally
  // Prevents race conditions between multiple input handlers and creation paths
  async ensureConversationExists(source = 'unknown') {
    // If we already have an active session, return it
    if (this.persistenceManager && this.persistenceManager.hasActiveSession()) {
      const existingSessionId = this.persistenceManager.getCurrentSessionId();
      console.log(`‚úÖ Using existing session: ${existingSessionId} (source: ${source})`);
      return { id: existingSessionId };
    }

    // If conversation creation is already in progress, wait for it
    if (this.isCreatingConversationGlobal && this.conversationCreationPromise) {
      console.log(`‚è≥ Conversation creation in progress, waiting... (source: ${source})`);
      try {
        const result = await this.conversationCreationPromise;
        console.log(`‚úÖ Conversation creation completed, using session: ${result.id} (source: ${source})`);
        return result;
      } catch (error) {
        console.error(`‚ùå Failed to wait for conversation creation (source: ${source}):`, error);
        // Reset state and try again
        this.isCreatingConversationGlobal = false;
        this.conversationCreationPromise = null;
      }
    }

    // Start new conversation creation with global mutex
    this.isCreatingConversationGlobal = true;
    console.log(`üîÑ Starting new conversation creation (source: ${source})...`);
    
    this.conversationCreationPromise = this.createNewConversationInternal(source);
    
    try {
      const result = await this.conversationCreationPromise;
      console.log(`‚úÖ Successfully created conversation: ${result.id} (source: ${source})`);
      this.currentConversationId = result.id;
      return result;
    } catch (error) {
      console.error(`‚ùå Failed to create conversation (source: ${source}):`, error);
      throw error;
    } finally {
      // Always reset the mutex when done
      this.isCreatingConversationGlobal = false;
      this.conversationCreationPromise = null;
    }
  }

  // Internal conversation creation logic (should only be called by ensureConversationExists)
  async createNewConversationInternal(source) {
    // Try persistence manager first
    if (this.persistenceManager) {
      try {
        console.log(`üîÑ Creating session via persistence manager (source: ${source})...`);
        const session = await this.persistenceManager.createSession(this.selectedAgent, 'New Chat');
        console.log(`‚úÖ Persistence manager session created: ${session.id}`);
        
        // Update sidebar to reflect the new conversation
        if (window.arzaniModernSidebar) {
          setTimeout(() => {
            window.arzaniModernSidebar.refresh();
          }, 500);
        }
        
        return session;
      } catch (persistenceError) {
        console.warn(`‚ö†Ô∏è Persistence manager failed (source: ${source}), falling back to direct API:`, persistenceError);
      }
    }

    // Fallback to direct API call
    const token = localStorage.getItem('token') || document.querySelector('meta[name="auth-token"]')?.content || this.getCookie('token');
    
    if (!token || token.trim() === '' || token === null || token === undefined) {
      throw new Error('No valid authentication token found for creating conversation');
    }

    console.log(`üîÑ Creating conversation via direct API (source: ${source})...`);
    const response = await fetch('/api/threads', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        group_name: `Chat ${new Date().toLocaleString()}`
      })
    });

    if (!response.ok) {
      throw new Error(`Failed to create conversation: ${response.status} ${response.statusText}`);
    }

    const newConversation = await response.json();
    console.log(`‚úÖ Direct API conversation created: ${newConversation.id}`);
    
    // Refresh sidebar conversations
    if (window.arzaniModernSidebar) {
      setTimeout(() => {
        window.arzaniModernSidebar.refresh();
        window.arzaniModernSidebar.currentConversationId = newConversation.id;
      }, 500);
    }
    
    return newConversation;
  }

  // ===== END CENTRALIZED CONVERSATION CREATION =====

  // Unified message handling method to ensure consistency between main and bottom inputs
  // This method centralizes all message processing to ensure that messages sent through 
  // either the main input box or bottom input box are treated identically and synchronized  // with both the main content conversation area AND the sidebar conversation list
  async handleUnifiedMessage(message, inputSource = 'main_input') {
    console.log(`üéØ [UNIFIED] handleUnifiedMessage called from ${inputSource} with message: "${message.substring(0, 50)}..."`);
    
    this.isProcessing = true;
    this.shouldStopProcessing = false;
    this.requestStartTime = Date.now(); // Track timing for analytics
      // Note: ThinkingPanel creation is handled later via createThinkingPanelWhenReady()
    // Legacy agentThinkingAnimation.start() call removed to prevent duplication
    
    // Update button states to show stop button
    this.updateButtonStates();
    
    // Log user message using A2A frontend logger
    if (window.a2aFrontendLogger) {
      await window.a2aFrontendLogger.logMessage(message, 'user', {
        agent: this.selectedAgent,
        inputMethod: inputSource,
        conversationStarted: this.conversationStarted
      });
      
      await window.a2aFrontendLogger.logUserInteraction('message_send', {
        messageLength: message.length,
        targetAgent: this.selectedAgent,
        inputSource: inputSource,
        timestamp: new Date().toISOString()
      });
    }
      
    // Transition to conversational layout on first message
    if (!this.conversationStarted) {
      await this.transitionToConversationLayout();
    }
        // Add user message to conversation area (main content body)
    const userMessageId = this.addConversationMessage(message, 'user');
      // Store in chat history
    this.chatHistory.push({ message, sender: 'user', timestamp: new Date() });    
    // Integrate with persistence manager for sidebar updates ONLY
    // Note: Message saving is handled by sendToA2A() to avoid duplication
    if (this.persistenceManager) {
      try {
        // Only update sidebar, don't save message (already saved in sendToA2A)
        await this.persistenceManager.updateConversationPreview(message, 'user');
        console.log('‚úÖ Message synchronized with sidebar via persistence manager');
      } catch (persistenceError) {
        console.warn('‚ö†Ô∏è Persistence integration warning:', persistenceError);
        // Don't throw - allow conversation to continue
      }
    }
    
    // Check if user stopped processing
    if (this.shouldStopProcessing) {
      this.isProcessing = false;
      this.updateButtonStates();
      return;
    }    // Add ThinkingPanel - wait for messages container to be ready
    await this.createThinkingPanelWhenReady();
        try {
      // Check if user stopped processing
      if (this.shouldStopProcessing) {
        // Remove thinking panel instead of loading message
        if (this.currentThinkingPanel) {
          this.currentThinkingPanel.remove();
          this.currentThinkingPanel = null;
        }
        if (this.currentThinkingMessageId) {
          const thinkingContainer = document.getElementById(this.currentThinkingMessageId);
          if (thinkingContainer) {
            thinkingContainer.remove();
          }
          this.currentThinkingMessageId = null;
        }
        this.isProcessing = false;
        this.updateButtonStates();
        return;  
      }
      
      // Send to selected A2A agent
      const response = await this.sendToA2A(message, userMessageId);
      
      // Check if user stopped processing
      if (this.shouldStopProcessing) {
        // Remove thinking panel instead of loading message
        if (this.currentThinkingPanel) {
          this.currentThinkingPanel.remove();
          this.currentThinkingPanel = null;
        }
        if (this.currentThinkingMessageId) {
          const thinkingContainer = document.getElementById(this.currentThinkingMessageId);
          if (thinkingContainer) {
            thinkingContainer.remove();
          }
          this.currentThinkingMessageId = null;
        }
        this.isProcessing = false;
        this.updateButtonStates();
        return;
      }
        // Finalize thinking panel and show completion
      if (this.currentThinkingPanel) {
        this.currentThinkingPanel.addThought("Response generated successfully!", true);
        this.currentThinkingPanel.completeAll();
        setTimeout(() => {
          if (this.currentThinkingPanel) {
            this.currentThinkingPanel.remove();
            this.currentThinkingPanel = null;
          }
          if (this.currentThinkingMessageId) {
            const thinkingContainer = document.getElementById(this.currentThinkingMessageId);
            if (thinkingContainer) {
              thinkingContainer.remove();
            }
            this.currentThinkingMessageId = null;
          }
        }, 2000); // Show completion for 2 seconds before removing
      }
      
      // Show disclaimer popup before first agent response if needed
      if (this.shouldShowDisclaimer()) {
        this.showDisclaimer();
      }
      
      // Add assistant response with copy button
      this.addConversationMessage(response, 'assistant');
      
      // Store in chat history
      this.chatHistory.push({ message: response, sender: 'assistant', timestamp: new Date(), agent: this.selectedAgent });
        // Integrate with persistence manager for AI response sidebar updates ONLY
      if (this.persistenceManager) {
        try {
          // Only update sidebar, don't save message (already saved in sendToA2A)
          await this.persistenceManager.updateConversationPreview(response, 'assistant');
          console.log('‚úÖ AI response synchronized with sidebar via persistence manager');
        } catch (persistenceError) {
          console.warn('‚ö†Ô∏è Failed to sync AI response with sidebar:', persistenceError);
        }
      }
      
      // Check for agent handoff in response
      const nextAgent = this.detectAgentHandoff(response);
      if (nextAgent && nextAgent !== this.selectedAgent && !this.shouldStopProcessing) {
        setTimeout(() => {
          this.handleAgentTransition(nextAgent, message);
        }, 1500); // Brief delay for better UX
      }
      
      // Update credits
      this.credits = Math.max(0, this.credits - 1);
      this.updateCreditsDisplay();
        } catch (error) {
      console.error('A2A Error:', error);
      
      // Remove thinking panel on error
      if (this.currentThinkingPanel) {
        this.currentThinkingPanel.remove();
        this.currentThinkingPanel = null;
      }
      if (this.currentThinkingMessageId) {
        const thinkingContainer = document.getElementById(this.currentThinkingMessageId);
        if (thinkingContainer) {
          thinkingContainer.remove();
        }
        this.currentThinkingMessageId = null;
      }
      
      // Enhanced error handling with retry mechanism
      let errorMessage = 'I encountered an issue processing your request. ';
      let showRetry = false;
      
      if (error.message.includes('offline')) {
        errorMessage += `The ${this.selectedAgent} agent is currently offline. `;
        errorMessage += 'I can try switching to another agent automatically.';
        showRetry = true;
      } else if (error.message.includes('HTTP 400')) {
        errorMessage += 'There was a communication error. This might be a temporary issue.';
        showRetry = true;
      } else if (error.message.includes('fetch')) {
        errorMessage += 'Network connection issue. Please check if all agents are running.';
        showRetry = true;
      } else {
        errorMessage += 'This appears to be an unexpected error.';
        showRetry = true;
      }
      
      this.addConversationMessage(errorMessage, 'assistant');
        
      if (showRetry && !this.shouldStopProcessing) {
        this.addRetryMessageToConversation(message);
      }
    }
    
    this.isProcessing = false;
      // Remove ThinkingPanel when processing is complete
    if (this.currentThinkingPanel) {
      this.currentThinkingPanel.remove();
      this.currentThinkingPanel = null;
    }
    if (this.currentThinkingMessageId) {
      const thinkingContainer = document.getElementById(this.currentThinkingMessageId);
      if (thinkingContainer) {
        thinkingContainer.remove();
      }
      this.currentThinkingMessageId = null;
    }
      this.updateButtonStates();
  }

  // Helper function to wait for messages container to be ready and create ThinkingPanel
  async createThinkingPanelWhenReady() {
    console.log('üéØ [THINKING] Creating ThinkingPanel for agent:', this.selectedAgent);
    
    // Prevent creating multiple ThinkingPanels
    if (this.currentThinkingPanel) {
      console.log('‚ö†Ô∏è ThinkingPanel already exists, skipping creation');
      return;
    }
    
    console.log('üîÑ [THINKING] Waiting for messages container...');
    
    // Wait for messages container to be available (up to 2 seconds)
    const messagesContainer = await this.waitForElement('messagesContainer', 2000);
    
    if (!messagesContainer) {
      console.error('‚ùå Messages container not found after waiting');
      return;
    }
      console.log('‚úÖ Messages container found, creating ThinkingPanel');
    
    // Create the ThinkingPanel directly (no need for AgentThinkingAnimation wrapper)
    const panelId = 'thinking-' + Date.now();
    const thinkingPanel = new ThinkingPanel(this.selectedAgent, panelId);
    
    if (!thinkingPanel || !thinkingPanel.element) {
      console.error('‚ùå ThinkingPanel creation failed');
      return;
    }
    
    // Create a container message for the thinking panel
    const thinkingMessageId = 'thinking-msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const thinkingContainer = document.createElement('div');
    thinkingContainer.id = thinkingMessageId;
    thinkingContainer.className = 'message-group ai-message thinking-message';
    thinkingContainer.appendChild(thinkingPanel.element);
    messagesContainer.appendChild(thinkingContainer);
    
    // Store reference for later removal
    this.currentThinkingPanel = thinkingPanel;
    this.currentThinkingMessageId = thinkingMessageId;
    
    console.log(`‚úÖ ThinkingPanel created and added to messages container for ${this.selectedAgent}`);
    
    // Auto-scroll to show the thinking panel
    setTimeout(() => {
      if (this.isUserNearBottom()) {
        this.smartScrollToBottom();
      }
    }, 100);
  }

  // Helper function to wait for an element to exist in the DOM
  async waitForElement(elementId, timeout = 5000) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const checkElement = () => {
        const element = document.getElementById(elementId);
        if (element) {
          console.log(`‚úÖ Element ${elementId} found after ${Date.now() - startTime}ms`);
          resolve(element);
          return;
        }
        
        if (Date.now() - startTime >= timeout) {
          console.warn(`‚è∞ Timeout waiting for element ${elementId} after ${timeout}ms`);
          resolve(null);
          return;
        }
        
        // Check again in 50ms
        setTimeout(checkElement, 50);
      };
      
      checkElement();
    });
  }
  async handleUserMessage() {
    console.log('üéØ [MAIN INPUT] handleUserMessage called');
    const message = this.input.value.trim();
    if (!message) return;

    // Clear input immediately to prevent double-submission
    this.input.value = '';
    this.resetTextareaHeight(this.input);

    // Delegate to the unified message handling method
    await this.handleUnifiedMessage(message, 'main_input');  }

  async sendToA2A(message, userMessageId = null) {
    const taskId = this.generateUUID();
    const selectedAgentUrl = this.agentUrls[this.selectedAgent];
      // Check if selected agent is online
    if (this.agentStatus[this.selectedAgent] !== 'online') {
      throw new Error(`${this.selectedAgent} agent is currently offline. Please try again later or select a different agent.`);
    }
    
    // Ensure we have an active conversation using centralized creation method
    try {
      const session = await this.ensureConversationExists('sendToA2A');
      this.currentConversationId = session.id;
    } catch (error) {
      console.error('‚ùå Failed to ensure conversation exists:', error);
      throw new Error('Failed to initialize conversation. Please try again.');
    }// First, save the user message to database with persistence manager
    if (this.persistenceManager) {
      try {
        console.log('üíæ Saving user message to database with client ID:', userMessageId);
        
        // Extract the client message ID from the DOM element if available
        let clientMessageId = userMessageId;
        if (userMessageId) {
          const messageElement = document.getElementById(userMessageId);
          if (messageElement) {
            clientMessageId = messageElement.getAttribute('data-client-message-id') || userMessageId;
          }
        }
        
        const savedMessage = await this.persistenceManager.saveMessage(
          message, 
          'user', 
          this.selectedAgent, 
          { client_message_id: clientMessageId }
        );
        
        // Update the frontend message element with the saved message data
        if (savedMessage && userMessageId) {
          const messageElement = document.getElementById(userMessageId);
          if (messageElement) {
            // Store both the database ID and ensure client message ID is preserved
            if (savedMessage.id) {
              messageElement.setAttribute('data-db-message-id', savedMessage.id);
            }
            if (savedMessage.message_id) {
              messageElement.setAttribute('data-client-message-id', savedMessage.message_id);
            }
            console.log(`‚úÖ Frontend message ${userMessageId} linked to database ID ${savedMessage.id} with client ID ${savedMessage.message_id}`);
          }
        }
        
        // Check if this is the first message and generate title
        const messages = await this.persistenceManager.loadMessages();
        if (messages && messages.length <= 1) {
          console.log('üéØ First message detected, generating conversation title...');
          await this.persistenceManager.generateConversationTitle(message);
        }
      } catch (error) {
        console.error('‚ùå Error saving user message:', error);
        // Continue with A2A call even if saving fails
      }
    }
    
    const requestPayload = {
      jsonrpc: '2.0',
      method: 'tasks/send',
      params: {
        task: {
          id: taskId,
          state: 'submitted'
        },
        message: {
          parts: [
            {
              type: 'text',
              text: message
            }
          ],
          role: 'user'
        }
      },
      id: this.generateRequestId()
    };

    const response = await fetch(selectedAgentUrl + '/a2a/tasks/send', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestPayload)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }    const data = await response.json();
    
    if (data.error) {
      throw new Error(data.error.message || 'A2A protocol error');
    }

    // Debug: Log the full response structure to understand the data format
    console.log('üîç Full A2A response data:', JSON.stringify(data, null, 2));

    // Extract the text response from the A2A message parts
    const responseParts = data.result?.message?.parts || [];
    const textParts = responseParts.filter(part => part.type === 'text');
    
    let aiResponse = 'No response received';
    if (textParts.length > 0) {
      aiResponse = textParts.map(part => part.text).join('\n');
    }    // Process ThinkingPanel data from orchestrator if available
    // Check multiple possible locations for the thinking panel data
    const thinkingPanelData = data.result?.thinkingPanel || 
                              data.result?.orchestratorData?.thinkingPanel ||
                              data.thinkingPanel ||
                              null;
    
    if (thinkingPanelData && this.currentThinkingPanel) {
      console.log('üß† Processing ThinkingPanel data from orchestrator:', thinkingPanelData);
      
      // Update the ThinkingPanel with real data from orchestrator
      if (thinkingPanelData.thoughts && thinkingPanelData.thoughts.length > 0) {
        this.currentThinkingPanel.updateWithServerData(thinkingPanelData.thoughts);
        console.log(`‚úÖ Updated ThinkingPanel with ${thinkingPanelData.thoughts.length} real thinking steps`);
      }
      
      // Mark as completed if the orchestrator indicates it's done
      if (thinkingPanelData.isActive === false) {
        setTimeout(() => {
          this.currentThinkingPanel.completeAll();
        }, thinkingPanelData.thoughts.length * 200 + 500);
      }
    } else {
      console.log('‚ö†Ô∏è No ThinkingPanel data found in response or no current ThinkingPanel available');
      console.log('Available data keys:', Object.keys(data.result || {}));
    }// Save AI response and update sidebar
    if (this.persistenceManager) {
      try {
        console.log('üíæ Saving AI response to database...');
        await this.persistenceManager.saveMessage(aiResponse, 'assistant', this.selectedAgent);
        
        // NOTE: onNewMessage call removed to prevent duplicate saves
        // Sidebar updates are handled separately in handleUnifiedMessage
        
        // Record agent interaction for analytics
        await this.persistenceManager.recordAgentInteraction({
          agent_name: this.selectedAgent,
          interaction_type: 'message_response',
          interaction_data: {
            task_id: taskId,
            user_message: message.substring(0, 100),
            response_length: aiResponse.length
          },
          response_time_ms: Date.now() - this.requestStartTime,
          success: true
        });
      } catch (persistenceError) {
        console.warn('‚ö†Ô∏è Persistence integration warning:', persistenceError);
        // Don't throw - allow conversation to continue even if persistence fails
      }
    }

    return aiResponse;
  }

  // ===== DISCLAIMER POPUP SYSTEM =====
    /**
   * Show disclaimer popup before first agent response
   */
  showDisclaimer() {
    if (this.disclaimerShown) {
      console.log('Disclaimer already shown, skipping');
      return;
    }
    
    console.log('Showing disclaimer popup');
    const disclaimerPopup = document.getElementById('disclaimerPopup');
    if (disclaimerPopup) {
      // Force remove hidden class and add visible class
      disclaimerPopup.classList.remove('hidden');
      disclaimerPopup.classList.add('visible');
      
      // Force visibility for debugging
      disclaimerPopup.style.visibility = 'visible';
      disclaimerPopup.style.opacity = '1';
      
      console.log('Disclaimer popup should now be visible');
      console.log('Popup classes:', disclaimerPopup.className);
      console.log('Popup style:', disclaimerPopup.style.cssText);
    } else {
      console.error('Disclaimer popup element not found!');
    }
  }
  
  /**
   * Accept disclaimer and mark as shown
   */
  acceptDisclaimer() {
    this.disclaimerShown = true;
    this.hideDisclaimer();
    
    // Store in session storage to persist during browser session
    sessionStorage.setItem('arzani_disclaimer_shown', 'true');
    
    console.log('Disclaimer accepted by user');
  }
  
  /**
   * Cancel/close disclaimer
   */
  cancelDisclaimer() {
    this.hideDisclaimer();
    
    // Add a message to the conversation explaining the disclaimer requirement
    if (this.conversationStarted) {
      this.addConversationMessage(
        '‚ö†Ô∏è Please note that AI-generated information requires professional consultation for important decisions. You can access this disclaimer again by refreshing the page.',
        'assistant'
      );
    }
  }
  
  /**
   * Hide disclaimer popup with animation
   */
  hideDisclaimer() {
    const disclaimerPopup = document.getElementById('disclaimerPopup');
    if (disclaimerPopup) {
      disclaimerPopup.classList.remove('visible');
      disclaimerPopup.classList.add('hidden');
    }
  }
    /**
   * Check if disclaimer should be shown before agent responses
   */
  shouldShowDisclaimer() {
    // Check if already shown in this session
    if (this.disclaimerShown) {
      console.log('Disclaimer check: already shown');
      return false;
    }
    
    // Check session storage
    const sessionShown = sessionStorage.getItem('arzani_disclaimer_shown');
    if (sessionShown === 'true') {
      console.log('Disclaimer check: found in session storage');
      this.disclaimerShown = true;
      return false;
    }
    
    console.log('Disclaimer check: should show');
    return true;
  }

  /**
   * Test method to manually show disclaimer (for debugging)
   */
  testShowDisclaimer() {
    console.log('Manual disclaimer test triggered');
    this.disclaimerShown = false; // Force reset for testing
    sessionStorage.removeItem('arzani_disclaimer_shown'); // Clear session storage
    this.showDisclaimer();
  }

  // ===== SEQUENTIAL AGENT DELEGATION SYSTEM =====
  
  /**
   * Set the active agent and update the banner
   */
  setActiveAgent(agentName) {
    if (!this.agentUrls[agentName]) {
      console.warn(`Unknown agent: ${agentName}`);
      return false;
    }
    
    const previousAgent = this.activeAgent;
    this.activeAgent = agentName;
    this.selectedAgent = agentName; // Keep backward compatibility
    
    // Update agent banner
    this.updateAgentBanner();
    
    // Create new agent section if switching agents
    if (previousAgent && previousAgent !== agentName) {
      this.addAgentSection(agentName);
    }
    
    console.log(`Active agent set to: ${agentName}`);
    return true;
  }
  
  /**
   * Update the agent banner with current active agent
   */
  updateAgentBanner() {
    if (!this.agentBanner || !this.agentBannerText || !this.activeAgent) return;
    
    const agentName = this.activeAgent;
    const colors = this.agentColors[agentName];
    const displayName = agentName.charAt(0).toUpperCase() + agentName.slice(1);
    
    // Update banner text and styling
    this.agentBannerText.textContent = `${displayName} Agent`;
    
    // Apply color scheme
    this.agentBanner.style.backgroundColor = colors.light;
    this.agentBanner.style.borderColor = colors.border;
    this.agentBanner.style.color = colors.primary;
    
    // Show banner if hidden
    if (this.agentBanner.classList.contains('hidden')) {
      this.agentBanner.classList.remove('hidden');
      // Add entrance animation
      this.agentBanner.style.animation = 'slideInFromTop 0.4s ease-out';
    }
  }
  
  /**
   * Add a new agent section to the conversation
   */
  addAgentSection(agentName) {
    if (!this.messagesContainer) return;
    
    const colors = this.agentColors[agentName];
    const displayName = agentName.charAt(0).toUpperCase() + agentName.slice(1);
    
    // Create agent section container
    const sectionDiv = document.createElement('div');
    sectionDiv.className = `agent-section agent-section-${agentName}`;
    sectionDiv.style.borderLeft = `4px solid ${colors.primary}`;
    sectionDiv.style.backgroundColor = colors.light;
    sectionDiv.style.padding = '16px';
    sectionDiv.style.margin = '16px 0';
    sectionDiv.style.borderRadius = '8px';
    sectionDiv.style.border = `1px solid ${colors.border}`;
    
    // Add section header
    const headerDiv = document.createElement('div');
    headerDiv.className = 'agent-section-header';
    headerDiv.style.display = 'flex';
    headerDiv.style.alignItems = 'center';
    headerDiv.style.marginBottom = '12px';
    headerDiv.style.color = colors.primary;
    headerDiv.style.fontWeight = '600';
    headerDiv.style.fontSize = '14px';
    
    headerDiv.innerHTML = `
      <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
        <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/>
      </svg>
      ${displayName} Agent Taking Over
    `;
    
    // Add messages container for this agent
    const messagesDiv = document.createElement('div');
    messagesDiv.className = `agent-messages agent-messages-${agentName}`;
    messagesDiv.style.display = 'flex';
    messagesDiv.style.flexDirection = 'column';
    messagesDiv.style.gap = '12px';
    
    sectionDiv.appendChild(headerDiv);
    sectionDiv.appendChild(messagesDiv);
    
    // Add to main messages container
    this.messagesContainer.appendChild(sectionDiv);
    
    // Set as current section
    this.currentAgentSection = messagesDiv;
    this.agentSections.push({
      agent: agentName,
      section: sectionDiv,
      messages: messagesDiv    });
    
    // Smart scroll to new section
    this.smartScrollToBottom();
  }
  
  /**
   * Detect agent handoff from response content
   */
  detectAgentHandoff(responseText) {
    const handoffPatterns = [
      /transferring.*to.*(\w+)\s*agent/i,
      /handing.*over.*to.*(\w+)\s*agent/i,
      /switching.*to.*(\w+)\s*agent/i,
      /redirecting.*to.*(\w+)\s*agent/i,
      /forwarding.*to.*(\w+)\s*agent/i,
      /connecting.*with.*(\w+)\s*agent/i,
      /delegating.*to.*(\w+)\s*agent/i
    ];
    
    for (const pattern of handoffPatterns) {
      const match = responseText.match(pattern);
      if (match) {
        const agentName = match[1].toLowerCase();
        if (this.agentUrls[agentName]) {
          return agentName;
        }
      }
    }
    
    // Check for direct agent mentions
    const agentNames = Object.keys(this.agentUrls);
    for (const agentName of agentNames) {
      const directPattern = new RegExp(`\\b${agentName}\\s*agent\\s*will\\s*handle`, 'i');
      if (directPattern.test(responseText)) {
        return agentName;
      }
    }
    
    return null;
  }
    /**
   * Add message to current agent section
   */
  addMessageToCurrentSection(content, sender, isLoading = false) {
    let targetContainer = this.messagesContainer;
    
    // Use agent-specific section if available
    if (this.currentAgentSection && this.activeAgent) {
      targetContainer = this.currentAgentSection;
    }
    
    const messageId = 'agent-msg-' + Date.now();
    const messageDiv = document.createElement('div');
    messageDiv.id = messageId;
    messageDiv.className = `message-fade-in flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-3 message-group ${sender === 'user' ? 'user-message' : 'ai-message'}`;
    messageDiv.setAttribute('data-message-id', messageId);
    messageDiv.setAttribute('data-sender', sender);
    messageDiv.setAttribute('data-original-content', content);
    
    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = `message-bubble max-w-xs lg:max-w-md px-4 py-3 rounded-lg text-sm relative group ${
      sender === 'user' 
        ? 'bg-black text-white rounded-br-none' 
        : 'bg-white text-black rounded-bl-none border border-gray-200'
    }`;

    if (isLoading) {
      bubbleDiv.innerHTML = `<span class="loading-dots">${content}</span>`;
    } else if (sender === 'assistant') {
      // Use markdown-aware typewriter animation for assistant messages
      bubbleDiv.innerHTML = '<div class="typewriter-text"></div><span class="typewriter-cursor">|</span>';
      
      // Determine if this message should be animated
      const contentHash = content.substring(0, 100).replace(/\s+/g, ' ').trim();
      const messageKey = `${this.currentConversationId || 'new'}-${contentHash}`;
      const hasBeenAnimated = this.animatedMessages.has(messageKey);
      
      // Only animate if: 1) not loading history, 2) message hasn't been animated before, 3) not a loading message
      const shouldAnimate = !this.isLoadingHistory && !hasBeenAnimated && !isLoading;
      
      if (shouldAnimate) {
        this.animatedMessages.add(messageKey);
        console.log('üé¨ Animating new agent message:', messageKey.substring(0, 50) + '...');
      } else if (this.isLoadingHistory) {
        console.log('üìú Skipping animation for historical agent message');
      } else if (hasBeenAnimated) {
        console.log('üîÑ Skipping animation for previously animated agent message');
      }
      
      this.animateTypewriter(bubbleDiv.querySelector('.typewriter-text'), content, messageId, shouldAnimate);
    } else if (sender === 'user') {
      // User messages with action buttons
      bubbleDiv.innerHTML = `
        <div class="message-content-wrapper">
          <div class="message-text" data-original-text="${this.escapeHtml(content)}">
            ${this.escapeHtml(content)}
          </div>
          <div class="message-actions">
            <button class="action-btn copy-btn" onclick="copyMessage('${messageId}')" title="Copy message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
            <button class="action-btn edit-btn" onclick="editMessage('${messageId}')" title="Edit message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
            </button>
            <button class="action-btn delete-btn" onclick="deleteMessage('${messageId}')" title="Delete message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3,6 5,6 21,6"></polyline>
                <path d="M19,6V20a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6M8,6V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2V6"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
            </button>
          </div>
        </div>
      `;
    } else {
      bubbleDiv.textContent = content;
    }

    messageDiv.appendChild(bubbleDiv);
    targetContainer.appendChild(messageDiv);
    
    // Smart scroll to bottom only if user is near bottom
    this.smartScrollToBottom();
    
    return messageId;
  }
  /**
   * Handle agent transition during conversation with persistence integration
   */
  async handleAgentTransition(newAgentName, originalMessage, transitionReason = '') {
    if (!this.agentUrls[newAgentName]) {
      console.warn(`Cannot transition to unknown agent: ${newAgentName}`);
      return false;
    }
    
    // Check if new agent is online
    if (this.agentStatus[newAgentName] !== 'online') {
      this.addMessageToCurrentSection(
        `‚ùå Cannot transition to ${newAgentName} agent - currently offline. Continuing with ${this.activeAgent} agent.`,
        'assistant'
      );
      return false;
    }
    
    // Set new active agent
    const previousAgent = this.activeAgent;
    this.setActiveAgent(newAgentName);
    
    // Record agent transition in persistence
    if (this.persistenceManager) {
      try {
        await this.persistenceManager.recordAgentTransition({
          from_agent: previousAgent || 'orchestrator',
          to_agent: newAgentName,
          transition_reason: transitionReason || 'agent_handoff_detected',
          context_data: {
            original_message: originalMessage.substring(0, 100) + '...',
            session_id: this.currentConversationId,
            transition_timestamp: new Date().toISOString(),
            user_initiated: false,
            automatic_handoff: true
          }
        });
      } catch (persistenceError) {
        console.warn('‚ö†Ô∏è Failed to record agent transition:', persistenceError);
      }
    }
    
    // Log agent transition using A2A frontend logger
    if (window.a2aFrontendLogger) {
      await window.a2aFrontendLogger.logAgentTransition(
        previousAgent || 'orchestrator',
        newAgentName,
        transitionReason || 'agent_handoff_detected',
        {
          originalMessage: originalMessage.substring(0, 100) + '...',
          sessionId: this.currentConversationId,
          transitionTimestamp: new Date().toISOString(),
          userInitiated: false,
          automaticHandoff: true
        }
      );
    }
    
    // Add agent section
    this.addAgentSection(newAgentName);
    
    // Add transition message
    const transitionMsg = transitionReason || 
      `üîÑ Transitioning from ${previousAgent} to ${newAgentName} agent for specialized assistance.`;
    this.addMessageToCurrentSection(transitionMsg, 'assistant');
    
    // Add loading message for new agent
    const loadingId = this.addMessageToCurrentSection(
      `${newAgentName.charAt(0).toUpperCase() + newAgentName.slice(1)} agent is analyzing your request...`,
      'assistant',
      true
    );
    
    try {
      // Track timing for new agent
      this.requestStartTime = Date.now();
      
      // Send message to new agent
      const response = await this.sendToA2A(originalMessage);
      
      // Remove loading message
      this.removeConversationMessage(loadingId);
      
      // Add new agent's response
      this.addMessageToCurrentSection(response, 'assistant');
      
      // Log successful agent transition
      if (window.a2aFrontendLogger) {
        await window.a2aFrontendLogger.logUserInteraction('agent_transition_success', {
          fromAgent: previousAgent,
          toAgent: newAgentName,
          responseReceived: true,
          responseLength: response.length,
          timestamp: new Date().toISOString()
        });
      }
      
      // Check for further handoffs
      const nextAgent = this.detectAgentHandoff(response);
      if (nextAgent && nextAgent !== newAgentName) {
        setTimeout(() => {
          this.handleAgentTransition(nextAgent, originalMessage, response);
        }, 1000);
      }
      
      return true;
    } catch (error) {
      console.error(`Agent transition error (${newAgentName}):`, error);
      this.removeConversationMessage(loadingId);
      
      // Log failed agent transition
      if (window.a2aFrontendLogger) {
        await window.a2aFrontendLogger.logUserInteraction('agent_transition_failed', {
          fromAgent: previousAgent,
          toAgent: newAgentName,
          error: error.message,
          timestamp: new Date().toISOString()
        });
      }
      
      // Revert to previous agent
      this.setActiveAgent(previousAgent);
      this.addMessageToCurrentSection(
        `‚ùå Failed to connect with ${newAgentName} agent. Reverting to ${previousAgent} agent.`,
        'assistant'
      );
      
      return false;
    }
  }
  // ===== END SEQUENTIAL AGENT DELEGATION SYSTEM =====
  addMessage(content, sender, isLoading = false) {
    const messageId = 'msg-' + Date.now();
    const messageDiv = document.createElement('div');
    messageDiv.id = messageId;
    messageDiv.className = `message-fade-in flex ${sender === 'user' ? 'justify-end' : 'justify-start'} mb-4`;
      const bubbleDiv = document.createElement('div');
    bubbleDiv.className = `max-w-xs lg:max-w-md px-4 py-2 rounded-lg text-sm message-bubble ${
      sender === 'user' 
        ? 'bg-black text-white' 
        : 'bg-gray-100 text-black'
    }`;
    
    if (isLoading) {
      bubbleDiv.innerHTML = `<span class="loading-dots">${content}</span>`;
    } else if (sender === 'user') {
      // User messages with action buttons
      bubbleDiv.innerHTML = `
        <div class="message-content-wrapper">
          <div class="message-text" data-original-text="${this.escapeHtml(content)}">
            ${this.escapeHtml(content)}
          </div>
          <div class="message-actions">
            <button class="action-btn copy-btn" onclick="copyMessage('${messageId}')" title="Copy message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
            <button class="action-btn edit-btn" onclick="editMessage('${messageId}')" title="Edit message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
            </button>
            <button class="action-btn delete-btn" onclick="deleteMessage('${messageId}')" title="Delete message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3,6 5,6 21,6"></polyline>
                <path d="M19,6V20a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6M8,6V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2V6"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
            </button>
          </div>
        </div>
      `;
      
      // Add data attributes for message identification
      messageDiv.setAttribute('data-message-id', messageId);
      messageDiv.setAttribute('data-sender', sender);
      messageDiv.setAttribute('data-original-content', content);
    } else {
      // AI messages get markdown rendering
      if (window.arzaniRenderer) {
        bubbleDiv.innerHTML = window.arzaniRenderer.renderToHtml(content, this.selectedAgent || 'orchestrator');
      } else {
        bubbleDiv.textContent = content;
      }
    }
    
    messageDiv.appendChild(bubbleDiv);
    
    // Append to chat messages container
    this.chatMessages.appendChild(messageDiv);
    
    // Scroll to bottom
    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
    
    return messageId;
  }

  removeMessage(messageId) {
    const message = document.getElementById(messageId);
    if (message) {
      message.remove();
    }
  }
  handleVoiceInput() {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      // Future implementation: actual voice recognition
      this.addConversationMessage('üé§ Voice input feature is being developed. Please type your message for now.', 'assistant');
    } else {
      this.addConversationMessage('Voice input is not supported in this browser. Please type your message.', 'assistant');
    }
  }  /**
   * Enhanced file upload with S3 backend integration
   * Supports multiple file types, progress tracking, and error handling
   */
  handleFileUpload() {
    // This method is now deprecated - use triggerFileInput instead
    this.triggerFileInput();
  }

  // Create hidden file input for file uploads
  createFileInput() {
    this.fileInput = document.createElement('input');
    this.fileInput.type = 'file';
    this.fileInput.style.display = 'none';
    this.fileInput.accept = '.pdf,.doc,.docx,.txt,.csv,.xlsx,.xls,.jpg,.jpeg,.png,.gif';
    this.fileInput.addEventListener('change', (e) => {
      this.handleFileSelection(e);
    });
    document.body.appendChild(this.fileInput);
  }

  // Trigger file input dialog
  triggerFileInput() {
    if (this.fileInput) {
      this.fileInput.click();
    }
  }

  // Handle file selection
  async handleFileSelection(event) {
    const files = event.target.files;
    if (files.length === 0) return;

    const file = files[0];
    
    // Validate file size (10MB limit)
    if (file.size > 10 * 1024 * 1024) {
      this.addConversationMessage('‚ùå File too large. Please select a file smaller than 10MB.', 'assistant');
      return;
    }

    // Show file preview and upload
    this.processFileUpload(file);
    
    // Clear the input for next use
    event.target.value = '';
  }  // Process file upload with preview
  async processFileUpload(file) {
    try {
      // Log file upload attempt using A2A frontend logger
      if (window.a2aFrontendLogger) {
        await window.a2aFrontendLogger.logFileUpload(file.name, file.type, file.size, {
          uploadMethod: 'drag_drop_or_button',
          targetAgent: this.selectedAgent,
          conversationId: this.currentConversationId,
          timestamp: new Date().toISOString()
        });
        
        await window.a2aFrontendLogger.logUserInteraction('file_upload_attempt', {
          fileName: file.name,
          fileType: file.type,
          fileSize: file.size,
          targetAgent: this.selectedAgent,
          timestamp: new Date().toISOString()
        });
      }
      
      // Add file preview message
      const previewId = this.addFilePreviewMessage(file);
      
      // Get user token - redirect to login if no valid token
      const token = localStorage.getItem('authToken');
      if (!token) {
        window.location.href = '/login?returnTo=' + encodeURIComponent(window.location.pathname);
        return;
      }
      
      // Create form data
      const formData = new FormData();
      formData.append('file', file);
      formData.append('type', 'chat-attachment');
      
      // Upload with progress
      const response = await this.uploadWithProgress(formData, token, previewId);
      
      if (response.success) {
        this.updateFilePreviewMessage(previewId, file, response, 'success');
        
        // Add file to conversation context
        this.addFileToContext(file, response);
        
        // Log successful file upload
        if (window.a2aFrontendLogger) {
          await window.a2aFrontendLogger.logUserInteraction('file_upload_success', {
            fileName: file.name,
            fileType: file.type,
            fileSize: file.size,
            uploadUrl: response.url,
            targetAgent: this.selectedAgent,
            timestamp: new Date().toISOString()
          });
        }
        
        // AI response about the file
        setTimeout(() => {
          this.addConversationMessage(
            `üìé I've received your file "${file.name}". I can help analyze or discuss its contents. What would you like to know about it?`,
            'assistant'
          );
        }, 1000);
        
      } else {
        throw new Error(response.error || 'Upload failed');
      }
      
    } catch (error) {
      console.error('File upload error:', error);
      
      // Log failed file upload
      if (window.a2aFrontendLogger) {
        await window.a2aFrontendLogger.logUserInteraction('file_upload_failed', {
          fileName: file.name,
          fileType: file.type,
          fileSize: file.size,
          error: error.message,
          targetAgent: this.selectedAgent,
          timestamp: new Date().toISOString()
        });
      }
      
      this.addConversationMessage(
        `‚ùå Upload failed for "${file.name}": ${error.message}`,
        'assistant'
      );
    }
  }

  // Add file preview message
  addFilePreviewMessage(file) {
    const messageId = 'file-' + Date.now();
    const messageDiv = document.createElement('div');
    messageDiv.id = messageId;
    messageDiv.className = 'message-group user-message message-fade-in';
    
    const fileIcon = this.getFileIcon(file.type);
    const fileSize = this.formatFileSize(file.size);
    
    messageDiv.innerHTML = `
      <div class="flex items-start space-x-3 justify-end">
        <div class="message-bubble bg-blue-600 text-white rounded-lg rounded-tr-none p-4 max-w-[80%]">
          <div class="file-preview flex items-center space-x-3">
            <div class="file-icon text-2xl">${fileIcon}</div>
            <div class="file-info flex-1">
              <div class="file-name font-medium">${file.name}</div>
              <div class="file-details text-sm opacity-90">${fileSize}</div>
              <div class="upload-progress mt-2">
                <div class="w-full bg-blue-400 rounded-full h-2">
                  <div class="progress-bar bg-white h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="progress-text text-xs mt-1">Uploading...</div>
              </div>
            </div>
          </div>
        </div>
        <div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center flex-shrink-0">
          <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
          </svg>
        </div>
      </div>
    `;
      this.messagesContainer.appendChild(messageDiv);
    this.smartScrollToBottom();
    
    return messageId;
  }

  // Update file preview with result
  updateFilePreviewMessage(messageId, file, response, status) {
    const messageElement = document.getElementById(messageId);
    if (!messageElement) return;
    
    const progressSection = messageElement.querySelector('.upload-progress');
    if (!progressSection) return;
    
    if (status === 'success') {
      progressSection.innerHTML = `
        <div class="flex items-center space-x-2 text-green-300">
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
          </svg>
          <span class="text-xs">Upload complete</span>
          <a href="${response.url}" target="_blank" class="text-xs underline hover:no-underline">View</a>
        </div>
      `;
    } else {
      progressSection.innerHTML = `
        <div class="flex items-center space-x-2 text-red-300">
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
          </svg>
          <span class="text-xs">Upload failed</span>
          <button class="text-xs underline hover:no-underline" onclick="window.arzaniClient.retryFileUpload('${file.name}')">Retry</button>
        </div>
      `;
    }
  }

  // Get file icon based on file type
  getFileIcon(fileType) {
    if (fileType.includes('pdf')) return 'üìÑ';
    if (fileType.includes('image')) return 'üñºÔ∏è';
    if (fileType.includes('doc')) return 'üìù';
    if (fileType.includes('sheet') || fileType.includes('excel')) return 'üìä';
    if (fileType.includes('text')) return 'üìÉ';
    return 'üìé';
  }

  // Format file size
  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  // Add file to conversation context
  addFileToContext(file, response) {
    this.conversationFiles = this.conversationFiles || [];
    this.conversationFiles.push({
      name: file.name,
      url: response.url,
      type: file.type,
      size: file.size,
      uploadTime: new Date().toISOString()
    });
  }

  // Retry file upload
  retryFileUpload(fileName) {
    this.addConversationMessage(`üîÑ Please select the file "${fileName}" again to retry upload.`, 'assistant');
    this.triggerFileInput();
  }
  // Setup sidebar navigation handlers
  setupSidebarNavigation() {
    // New Chat button
    const newChatButton = document.querySelector('.link-item:first-child');
    if (newChatButton) {
      newChatButton.addEventListener('click', () => {
        this.createNewChat();
      });
    }

    // History button
    const historyButton = document.querySelector('.link-item:last-child');
    if (historyButton) {
      historyButton.addEventListener('click', () => {
        this.toggleChatHistory();
      });
    }

    // Mobile sidebar functionality
    this.setupMobileSidebarHandlers();

    // Load initial chat history
    this.loadChatHistory();
  }

  // Setup mobile sidebar functionality
  setupMobileSidebarHandlers() {
    const mobileSidebarToggle = document.getElementById('mobileSidebarToggle');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const modernSidebar = document.getElementById('modernSidebar');

    if (!mobileSidebarToggle || !sidebarOverlay || !modernSidebar) {
      console.warn('‚ö†Ô∏è Mobile sidebar elements not found');
      return;
    }

    // Mobile sidebar toggle button
    mobileSidebarToggle.addEventListener('click', () => {
      this.openMobileSidebar();
    });

    // Sidebar overlay click to close
    sidebarOverlay.addEventListener('click', () => {
      this.closeMobileSidebar();
    });

    // Close sidebar on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modernSidebar.classList.contains('mobile-open')) {
        this.closeMobileSidebar();
      }
    });

    console.log('üì± Mobile sidebar functionality initialized');
  }

  // Open mobile sidebar
  openMobileSidebar() {
    const modernSidebar = document.getElementById('modernSidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');

    if (modernSidebar && sidebarOverlay) {
      modernSidebar.classList.add('mobile-open');
      sidebarOverlay.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent body scroll
      console.log('üì± Mobile sidebar opened');
    }
  }

  // Close mobile sidebar
  closeMobileSidebar() {
    const modernSidebar = document.getElementById('modernSidebar');
    const sidebarOverlay = document.getElementById('sidebarOverlay');

    if (modernSidebar && sidebarOverlay) {
      modernSidebar.classList.remove('mobile-open');
      sidebarOverlay.classList.remove('active');
      document.body.style.overflow = ''; // Restore body scroll
      console.log('üì± Mobile sidebar closed');
    }
  }  // Switch between conversations
  async switchToConversation(conversationId) {
    try {
      // Save current conversation if exists
      if (this.currentConversationId && this.chatHistory.length > 0) {
        await this.saveConversationMessages();
      }

      // Clear animation state for conversation switch
      this.isLoadingHistory = false;
      this.animatedMessages.clear();
      console.log('üîÑ Switching to conversation:', conversationId);

      // Ensure conversation layout is active (without animation)
      this.ensureConversationLayout();

      // Load selected conversation
      this.currentConversationId = conversationId;
      await this.loadConversationMessages(conversationId);
      
      console.log(`‚úÖ Switched to conversation: ${conversationId}`);
    } catch (error) {
      console.error('Error switching conversation:', error);
      this.addConversationMessage('‚ùå Failed to load conversation. Please try again.', 'assistant');
    }
  }

  // Ensure conversation layout is active without animation (for conversation switching)
  ensureConversationLayout() {
    if (!this.conversationStarted) {
      this.conversationStarted = true;
    }
    
    // Apply conversation mode immediately without animation
    const contentBody = document.querySelector('.content-body');
    if (contentBody && !contentBody.classList.contains('conversation-mode')) {
      contentBody.classList.add('conversation-mode');
    }
    
    // Hide main elements and show conversation elements
    this.mainHeading.style.display = 'none';
    this.mainFormContainer.style.display = 'none';
    this.conversationArea.classList.remove('hidden');
    this.bottomInputArea.classList.remove('hidden');
    
    // Mark that initial page load is complete (in case it wasn't already)
    this.isInitialPageLoad = false;
  }  // Load messages for a specific conversation - synchronizes sidebar selection with main content area
  async loadConversationMessages(conversationId) {
    try {
      // Set flag to prevent animations for historical messages
      this.isLoadingHistory = true;
      console.log('üìú Loading historical messages for conversation:', conversationId);
      
      // Ensure conversation layout is active when loading messages
      this.ensureConversationLayout();
      
      const token = localStorage.getItem('authToken');
      if (!token) {
        window.location.href = '/login?returnTo=' + encodeURIComponent(window.location.pathname);
        return;
      }

      const response = await fetch(`/api/threads/${conversationId}/messages`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (response.ok) {
        const messages = await response.json();
        console.log('üì¨ Loaded', messages.length, 'historical messages');
        
        // Clear current messages
        this.messagesContainer.innerHTML = '';
        this.chatHistory = [];        // Display messages (with animations disabled via isLoadingHistory flag)
        messages.forEach((message, index) => {
          const content = message.content || message.message;
          const role = message.sender_id === this.userId ? 'user' : 'assistant';
          this.addConversationMessage(content, role, false, message.created_at, true); // Don't save to history again, disable animations
        });
        
        this.scrollToBottom();
        
        // Update chat context header
        const conversation = window.arzaniModernSidebar?.conversations[conversationId];
        if (conversation) {
          this.updateChatContextHeader(
            conversation.group_name || 'Conversation',
            conversation.agent_type || this.selectedAgent,
            messages.length,
            conversation.last_message_time || conversation.updated_at
          );
        }
        
        // Reset flag after loading history - ready for new animations
        this.isLoadingHistory = false;
        console.log('‚úÖ Historical messages loaded, ready for new animations');
      } else {
        this.isLoadingHistory = false;
        throw new Error('Failed to load conversation messages');
      }
    } catch (error) {
      this.isLoadingHistory = false;
      console.error('Error loading conversation messages:', error);
      this.addConversationMessage('‚ùå Failed to load conversation messages.', 'assistant');
    }
  }
  // Save current conversation messages
  async saveConversationMessages() {
    if (!this.currentConversationId || this.chatHistory.length === 0) return;

    try {
      const token = localStorage.getItem('authToken');
      if (!token) {
        window.location.href = '/login?returnTo=' + encodeURIComponent(window.location.pathname);
        return;
      }
        // Send messages to backend for persistence
      for (const message of this.chatHistory) {
        if (message.saved) continue; // Skip already saved messages
        
        await fetch(`/api/threads/${this.currentConversationId}/send`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            content: message.message,
            role: message.agent
          })
        });

        message.saved = true;
      }
    } catch (error) {
      console.error('Error saving conversation messages:', error);
    }
  }
  // Create new chat conversation with enhanced persistence integration
  async createNewChat() {
    console.log('üîÑ Starting new chat creation...');
    
    try {
      // Check if this is creating a new chat while already in conversation mode
      const wasInConversationMode = this.conversationStarted;
      
      // Clear current conversation
      this.clearCurrentConversation();
      
      // If we were already in conversation mode, ensure we stay in conversation layout
      if (wasInConversationMode) {
        this.ensureConversationLayout();
      }
      
      // Create new conversation using centralized method
      const session = await this.ensureConversationExists('createNewChat');
      this.currentConversationId = session.id;
      console.log(`‚úÖ Conversation session created: ${session.id}`);
      
      // Clear main chat input if persistence manager is available
      if (this.persistenceManager && this.persistenceManager.clearMainChatInput) {
        this.persistenceManager.clearMainChatInput();
      }
      
      // Show welcome message
      this.showWelcomeMessage();
      
      console.log('‚úÖ New chat created successfully');
      
    } catch (error) {
      console.error('Error creating new chat:', error);
      // Fallback to local new chat
      this.clearCurrentConversation();
      this.showWelcomeMessage();
    }
  }
  // Clear current conversation
  clearCurrentConversation() {
    this.messagesContainer.innerHTML = '';
    this.chatHistory = [];
    this.conversationFiles = [];
    this.conversationStarted = false;
    this.currentConversationId = null;
    this.isLoadingHistory = false;
    this.animatedMessages.clear(); // Reset animation tracking
    console.log('üßπ Cleared conversation and reset animation tracking');
    
    // Hide chat context header when no conversation is active
    const chatHeader = document.getElementById('chatContextHeader');
    if (chatHeader) {
      chatHeader.style.display = 'none';
    }
  }// Show welcome message  // Show welcome message
  showWelcomeMessage() {
    // Ensure animation state is properly reset for new conversations
    this.isLoadingHistory = false;
    console.log('üëã Showing welcome message - animations enabled');
    
    const welcomeMessage = "Hello! I'm Arzani, your AI business marketplace assistant. I can help you with business valuations, finding listings, legal advice, and financial guidance. What would you like to know?";
    this.addConversationMessage(welcomeMessage, 'assistant');
  }

  // Show welcome message without clearing conversation state (used for empty conversations)
  showWelcomeMessageInConversation() {
    this.messagesContainer.innerHTML = `
      <div class="message-group ai-message">
        <div class="message-bubble">
          <p>Hello! I'm Arzani, your AI business marketplace assistant. I can help you with business valuations, finding listings, legal advice, and financial guidance. What would you like to know?</p>
        </div>
      </div>
    `;
  }

  // Utility method to get cookie value
  getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
  }// Load chat history from backend - now delegates to sidebar to avoid duplicate API calls
  async loadChatHistory() {
    try {
      const token = localStorage.getItem('token') || document.querySelector('meta[name="auth-token"]')?.content || this.getCookie('token');
      
      // Validate token before sending request - fix string comparison issue
      if (!token || token.trim() === '' || token === null || token === undefined) {
        console.warn('No valid authentication token found for loading chat history');
        // Show empty history container
        this.displayChatHistory([]);
        return;
      }
      
      console.log('Delegating chat history loading to sidebar to prevent duplicate API calls...');
      
      // If modern sidebar exists, delegate to it to avoid duplicate API calls
      if (window.arzaniModernSidebar && typeof window.arzaniModernSidebar.refresh === 'function') {
        console.log('üìã Using sidebar refresh (debounced) instead of direct API call');
        window.arzaniModernSidebar.refresh(); // This is debounced
        
        // Load A2A sessions for backwards compatibility 
        if (this.persistenceManager) {
          try {
            const a2aConversations = await this.persistenceManager.getUserSessions();
            console.log('Loaded A2A conversations for legacy compatibility:', a2aConversations.length);
            // Display legacy history if needed, but don't make additional API calls
            if (a2aConversations.length > 0) {
              this.displayChatHistory(a2aConversations);
            }
          } catch (error) {
            console.warn('Failed to load A2A conversations:', error);
            this.displayChatHistory([]);
          }
        }
        return;
      }
      
      // Fallback: make API call only if sidebar isn't available
      console.log('Loading chat history directly (sidebar not available)...');
      
      const response = await fetch('/api/threads', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      let regularConversations = [];
      if (response.ok) {
        const data = await response.json();
        // Handle bucketed API response format
        if (data.success && data.data) {
          // Flatten bucketed conversations into a single array
          const buckets = data.data;
          regularConversations = [
            ...(buckets.pinned || []),
            ...(buckets.today || []),
            ...(buckets.yesterday || []),
            ...(buckets.last7Days || []),
            ...(buckets.older || [])
          ];
        } else if (data.conversations) {
          // Fallback for direct conversations array
          regularConversations = data.conversations;
        } else if (Array.isArray(data)) {
          // Fallback for direct array response
          regularConversations = data;
        }
      } else {
        console.log('No regular chat history available');
      }
      
      // Combine A2A and regular conversations
      const allConversations = [...a2aConversations, ...regularConversations];
      
      // Sort by most recent activity
      allConversations.sort((a, b) => {
        const dateA = new Date(a.updated_at || a.created_at);
        const dateB = new Date(b.updated_at || b.created_at);
        return dateB - dateA;
      });
      
      this.displayChatHistory(allConversations);
        } catch (error) {
      console.error('Error loading chat history:', error);
      this.displayChatHistory([]);
    }
  }

  // Display chat history in modern sidebar
  displayChatHistory(conversations) {
    // Check if modern sidebar exists and delegate to it
    if (window.arzaniModernSidebar) {
      console.log('Delegating chat history to modern sidebar');
      // The modern sidebar will handle conversation display through its own methods
      // No need to create duplicate containers
      return;
    }

    // Fallback: Only run if modern sidebar is not available
    console.log('Modern sidebar not available, using fallback chat history display');
    
    if (!conversations || conversations.length === 0) {
      console.log('No conversations to display');
      return;
    }

    // Sort conversations by updated_at (newest first)
    const sortedConversations = conversations.sort((a, b) => {
      return new Date(b.updated_at || b.created_at) - new Date(a.updated_at || a.created_at);
    });

    console.log(`Displaying ${sortedConversations.length} conversations in fallback mode`);
  }    // Modern sidebar integration - no need to create history containers
  // The ArzaniModernSidebar class handles conversation display in organized sections
  // Legacy method - modern sidebar handles conversation items internally
  // This is kept for fallback compatibility only
  createHistoryItem(conversation) {
    console.log('createHistoryItem called - consider using modern sidebar instead');
    
    const item = document.createElement('div');
    item.className = 'history-item w-full mb-1 rounded-lg flex items-center px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm';
    
    const date = new Date(conversation.created_at).toLocaleDateString();
    const name = conversation.group_name || `Chat ${date}`;
    
    item.innerHTML = `
      <svg class="w-4 h-4 mr-2 text-gray-500" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clip-rule="evenodd"/>
      </svg>
      <span class="truncate flex-1 text-gray-700">${name}</span>
    `;
    
    item.addEventListener('click', () => {
      this.loadConversation(conversation.id);
    });
    
    return item;
  }
    // Modern sidebar handles visibility - this is a legacy method
  toggleChatHistory() {
    console.log('toggleChatHistory called - modern sidebar handles visibility automatically');
    
    // For compatibility, check if modern sidebar exists
    if (window.arzaniModernSidebar) {
      // Modern sidebar handles its own visibility
      return;
    }
    
    // Fallback for legacy chat-history-container
    const historyContainer = document.querySelector('.chat-history-container');
    if (historyContainer) {
      historyContainer.classList.toggle('hidden');
    }
  }
  
  // Load specific conversation
  async loadConversation(conversationId) {
    try {
      const token = localStorage.getItem('authToken');
      if (!token) {
        window.location.href = '/login?returnTo=' + encodeURIComponent(window.location.pathname);
        return;
      }
        const response = await fetch(`/api/threads/${conversationId}/messages`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (response.ok) {
        const messages = await response.json();
        this.displayConversationMessages(messages);
        this.currentConversationId = conversationId;
        
        // Hide history after selection
        this.toggleChatHistory();
      }
      
    } catch (error) {
      console.error('Error loading conversation:', error);
    }  }
    // Display conversation messages
  displayConversationMessages(messages) {
    this.clearCurrentConversation();
    
    messages.forEach(message => {
      const role = message.sender_type === 'user' ? 'user' : 'assistant';
      this.addConversationMessage(message.content, role, false, message.created_at, true); // Disable animation for previous conversations
      
      // Handle attachments
      if (message.attachments && message.attachments.length > 0) {
        message.attachments.forEach(attachment => {
          this.displayAttachment(attachment);
        });
      }
    });
  }

  // Display file attachment in conversation
  displayAttachment(attachment) {
    const attachmentDiv = document.createElement('div');
    attachmentDiv.className = 'message-group user-message message-fade-in mb-2';
    
    const fileIcon = this.getFileIcon(attachment.file_type);
    
    attachmentDiv.innerHTML = `
      <div class="flex items-start space-x-3 justify-end">
        <div class="message-bubble bg-blue-600 text-white rounded-lg rounded-tr-none p-3 max-w-[80%]">
          <div class="file-attachment flex items-center space-x-3">
            <div class="file-icon text-xl">${fileIcon}</div>
            <div class="file-info flex-1">
              <div class="file-name text-sm font-medium">${attachment.original_filename}</div>
              <a href="${attachment.file_url}" target="_blank" class="text-xs underline hover:no-underline">View File</a>
            </div>
          </div>
        </div>
        <div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center flex-shrink-0">
          <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"/>
          </svg>
        </div>
      </div>    `;
    
    this.messagesContainer.appendChild(attachmentDiv);  }
  
  // Enhanced file upload method to replace the broken implementation
  triggerFileInput() {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.multiple = true;
    fileInput.accept = '.pdf,.doc,.docx,.txt,.png,.jpg,.jpeg,.gif,.webp,.csv,.xlsx,.zip';
    fileInput.style.display = 'none';
    
    const maxFileSize = 10 * 1024 * 1024; // 10MB
    const allowedTypes = [
      'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'text/plain', 'image/png', 'image/jpeg', 'image/gif', 'image/webp',
      'text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/zip'
    ];

    fileInput.onchange = async (event) => {
      const files = event.target.files;
      if (!files.length) return;
      
      const validFiles = [];
      const errors = [];
      
      for (const file of files) {
        if (file.size > maxFileSize) {
          errors.push(`${file.name}: File too large (max 10MB)`);
        } else if (!allowedTypes.includes(file.type) && !file.name.match(/\.(pdf|doc|docx|txt|png|jpg|jpeg|gif|webp|csv|xlsx|zip)$/i)) {
          errors.push(`${file.name}: Unsupported file type`);
        } else {
          validFiles.push(file);
        }
      }
      
      // Show validation errors
      if (errors.length > 0) {
        this.addConversationMessage(`‚ùå Upload errors:\n${errors.join('\n')}`, 'assistant');
      }
      
      if (validFiles.length === 0) return;
      
      // Process valid files
      for (const file of validFiles) {
        await this.uploadFileToS3(file);
      }
    };
    
    document.body.appendChild(fileInput);
    fileInput.click();
    document.body.removeChild(fileInput);
  }
  
  /**
   * Upload file to S3 with progress tracking and retry mechanism
   */
  async uploadFileToS3(file) {
    const messageId = this.addConversationMessage(
      `üì§ Uploading ${file.name}... <div class="upload-progress"><div class="progress-bar" style="width: 0%"></div></div>`,
      'user'
    );
    
    try {
      // Get authentication token
      const token = localStorage.getItem('token') || sessionStorage.getItem('token');
      if (!token) {
        throw new Error('Authentication required for file upload');
      }
      
      // Create FormData
      const formData = new FormData();
      formData.append('file', file);
      formData.append('uploadContext', 'a2a-chat');
      
      // Upload with progress tracking
      const response = await this.uploadWithProgress(formData, token, messageId);
      
      if (response.success) {
        // Update message with success
        this.updateConversationMessage(messageId, 
          `‚úÖ ${file.name} uploaded successfully! <a href="${response.url}" target="_blank" class="file-link">View File</a>`
        );
        
        // Add file context to conversation
        this.conversationFiles = this.conversationFiles || [];
        this.conversationFiles.push({
          name: file.name,
          url: response.url,
          type: file.type,
          size: file.size,
          uploadTime: new Date().toISOString()
        });
        
        // Notify AI about the uploaded file
        this.addConversationMessage(
          `üìé I've received your file "${file.name}". I can help analyze or discuss its contents. What would you like to know about it?`,
          'assistant'
        );
        
      } else {
        throw new Error(response.error || 'Upload failed');
      }
      
    } catch (error) {
      console.error('File upload error:', error);
      this.updateConversationMessage(messageId, 
        `‚ùå Upload failed: ${file.name} - ${error.message} <button onclick="retryUpload('${file.name}')" class="retry-btn">Retry</button>`
      );
    }
  }
  
  /**
   * Upload with XMLHttpRequest for progress tracking
   */
  uploadWithProgress(formData, token, messageId) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      
      // Track upload progress
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percentComplete = Math.round((e.loaded / e.total) * 100);
          const progressBar = document.querySelector(`#${messageId} .progress-bar`);
          if (progressBar) {
            progressBar.style.width = percentComplete + '%';
            progressBar.textContent = percentComplete + '%';
          }
        }
      });
      
      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          try {
            const response = JSON.parse(xhr.responseText);
            resolve(response);
          } catch (e) {
            reject(new Error('Invalid response format'));
          }
        } else {
          reject(new Error(`Upload failed with status: ${xhr.status}`));
        }
      });
      
      xhr.addEventListener('error', () => {
        reject(new Error('Network error during upload'));
      });
      
      xhr.addEventListener('timeout', () => {
        reject(new Error('Upload timeout'));
      });
      
      // Configure request
      xhr.open('POST', '/api/s3-upload');
      xhr.setRequestHeader('Authorization', `Bearer ${token}`);
      xhr.timeout = 60000; // 60 second timeout
      
      // Send request
      xhr.send(formData);
    });
  }

  // Show agent capabilities without popup
  showAgentCapabilities() {
    const agentCapabilities = {
      orchestrator: [
        'Multi-Agent Task Coordination',
        'Business Query Routing',
        'Complex Workflow Management',
        'Agent Status Monitoring',
        'Task Prioritization'
      ],
      broker: [
        'Business Valuation & Analysis',
        'Market Trend Analysis', 
        'Investment Opportunity Assessment',
        'Business Listing Management',
        'Buyer-Seller Matching'
      ],
      legal: [
        'Legal Document Generation',
        'Compliance & Regulations Review',
        'Contract Analysis',
        'Due Diligence Support',
        'Legal Risk Assessment'
      ],
      finance: [
        'Financial Planning & Analysis',
        'Cash Flow Projections',
        'Investment Portfolio Review',
        'Tax Optimization Strategies',
        'Financial Risk Analysis'
      ]
    };
    
    const tools = agentCapabilities[this.selectedAgent] || agentCapabilities.orchestrator;
    const agentName = this.selectedAgent.charAt(0).toUpperCase() + this.selectedAgent.slice(1);
    const toolsMessage = `üõ†Ô∏è ${agentName} Agent Capabilities:\n\n${tools.map(tool => `‚Ä¢ ${tool}`).join('\n')}\n\nüí¨ Just ask me about any of these topics!`;
    
    // Transition to conversation if not already started
    if (!this.conversationStarted) {
      this.transitionToConversationLayout();
    }
    
    this.addConversationMessage(toolsMessage, 'assistant');
  }
  // Agent Status Monitoring Methods
  initializeAgentStatus() {
    // Set all agents as online by default
    Object.keys(this.agentUrls).forEach(agentName => {
      this.agentStatus[agentName] = 'online';
      this.updateAgentStatusUI(agentName, 'online');
    });
  }

  async startHealthCheck() {
    // Initial check
    await this.checkAllAgents();
    
    // Set up periodic health checks every 10 seconds
    setInterval(() => {
      this.checkAllAgents();
    }, 10000);
  }

  async checkAllAgents() {
    const checkPromises = Object.entries(this.agentUrls).map(([name, url]) => 
      this.checkAgentHealth(name, url)
    );
    
    await Promise.all(checkPromises);
  }

  async checkAgentHealth(agentName, agentUrl) {
    try {
      const response = await fetch(`${agentUrl}/.well-known/agent.json`, {
        method: 'GET',
        timeout: 5000
      });
      
      if (response.ok) {
        const agentInfo = await response.json();
        this.agentStatus[agentName] = 'online';
        this.updateAgentStatusUI(agentName, 'online');
        console.log(`${agentName} agent is online:`, agentInfo.name);
      } else {
        this.agentStatus[agentName] = 'offline';
        this.updateAgentStatusUI(agentName, 'offline');
      }
    } catch (error) {
      this.agentStatus[agentName] = 'offline';
      this.updateAgentStatusUI(agentName, 'offline');
      console.warn(`${agentName} agent health check failed:`, error.message);
    }
  }

  updateAgentStatusUI(agentName, status) {
    const statusElement = document.getElementById(`${agentName}Status`);
    if (statusElement) {
      // Remove existing status classes
      statusElement.classList.remove('status-online', 'status-offline', 'status-checking');
      
      // Add new status class
      statusElement.classList.add(`status-${status}`);
      
      // Update status text
      const statusText = statusElement.querySelector('.status-text');
      if (statusText) {
        statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      }
    }
  }
  updateSelectedAgentUI() {
    // Update UI to show which agent is selected
    const agentNameElement = document.querySelector('.chat-header .agent-name');
    if (agentNameElement) {
      agentNameElement.textContent = `Arzani ${this.selectedAgent.charAt(0).toUpperCase() + this.selectedAgent.slice(1)}`;
    }
    
    // Update agent status indicator in chat header
    const headerStatusIndicator = document.querySelector('.chat-header .w-2.h-2');
    if (headerStatusIndicator) {
      headerStatusIndicator.classList.remove('bg-green-400', 'bg-red-400', 'bg-yellow-400');
      
      switch(this.agentStatus[this.selectedAgent]) {
        case 'online':
          headerStatusIndicator.classList.add('bg-green-400');
          break;
        case 'offline':
          headerStatusIndicator.classList.add('bg-red-400');
          break;
        default:
          headerStatusIndicator.classList.add('bg-yellow-400');
      }
    }  }
  // Handle bottom input area message submission with persistence integration  
  async handleBottomUserMessage() {
    console.log('üéØ [BOTTOM INPUT] handleBottomUserMessage called');
    const message = this.bottomChatInput.value.trim();
    if (!message) return;

    // Clear input immediately to prevent double-submission
    this.bottomChatInput.value = '';
    this.resetTextareaHeight(this.bottomChatInput);    // Delegate to the unified message handling method
    await this.handleUnifiedMessage(message, 'bottom_input');
  }
  // Add message to conversation area with ChatGPT-style layout and typewriter animation  // This method displays messages in the main content body conversation area.
  // Sidebar synchronization is handled by the persistence manager in handleUnifiedMessage()
  addConversationMessage(content, sender, isLoading = false, timestamp = null, disableAnimation = false) {
    // Generate proper client message ID (consistent with persistence layer format)
    const messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    const messageDiv = document.createElement('div');
    messageDiv.id = messageId;
    // Only add fade-in animation class if animations are not disabled
    const fadeInClass = disableAnimation ? '' : 'message-fade-in ';
    messageDiv.className = `${fadeInClass}message-group ${sender === 'user' ? 'user-message' : 'ai-message'}`;
    
    const bubbleDiv = document.createElement('div');
      if (sender === 'user') {
      // User messages: compact style on the right with action buttons
      bubbleDiv.className = 'message-bubble bg-black text-white rounded-lg rounded-br-none px-4 py-3 max-w-xs lg:max-w-md';
      bubbleDiv.innerHTML = `
        <div class="message-content-wrapper">
          <div class="message-text" data-original-text="${this.escapeHtml(content)}">
            ${this.escapeHtml(content)}
          </div>
          <div class="message-actions">
            <button class="action-btn copy-btn" onclick="copyMessage('${messageId}')" title="Copy message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
            <button class="action-btn edit-btn" onclick="editMessage('${messageId}')" title="Edit message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
            </button>
            <button class="action-btn delete-btn" onclick="deleteMessage('${messageId}')" title="Delete message">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3,6 5,6 21,6"></polyline>
                <path d="M19,6V20a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6M8,6V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2V6"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
            </button>
          </div>
        </div>      `;
      
      // Add data attributes for message identification
      messageDiv.setAttribute('data-message-id', messageId);
      messageDiv.setAttribute('data-client-message-id', messageId); // Store client message ID for editing
      messageDiv.setAttribute('data-sender', sender);
      messageDiv.setAttribute('data-original-content', content);
      
      // Create flex container for user messages
      const flexContainer = document.createElement('div');
      flexContainer.className = 'flex justify-end';
      flexContainer.appendChild(bubbleDiv);
      messageDiv.appendChild(flexContainer);
    } else {
      // AI messages: ChatGPT full-width style
      bubbleDiv.className = 'message-bubble';
        if (isLoading) {
        bubbleDiv.innerHTML = `<div class="loading-dots">${content}</div>`;
      } else {
        // Format content with proper markdown-aware typewriter animation
        const formattedContent = this.formatAIResponse(content);
        bubbleDiv.innerHTML = '<div class="typewriter-text"></div><span class="typewriter-cursor">|</span>';
        
        // Determine if this message should be animated
        const contentHash = content.substring(0, 100).replace(/\s+/g, ' ').trim();
        const messageKey = `${this.currentConversationId || 'new'}-${contentHash}`;
        const hasBeenAnimated = this.animatedMessages.has(messageKey);
        
        // Only animate if: 1) not disabled by parameter, 2) not loading history, 3) message hasn't been animated before, 4) not a loading message
        const shouldAnimate = !disableAnimation && !this.isLoadingHistory && !hasBeenAnimated && !isLoading;
        
        if (shouldAnimate) {
          this.animatedMessages.add(messageKey);
          console.log('üé¨ Animating new message:', messageKey.substring(0, 50) + '...');
        } else if (disableAnimation) {
          console.log('üö´ Animation disabled for message');
        } else if (this.isLoadingHistory) {
          console.log('üìú Skipping animation for historical message');
        } else if (hasBeenAnimated) {
          console.log('üîÑ Skipping animation for previously animated message');
        }
        
        this.animateTypewriter(bubbleDiv.querySelector('.typewriter-text'), formattedContent, messageId, shouldAnimate);
        
        // Add copy button for assistant messages after typing is complete (faster timing)
        const copyButtonDelay = shouldAnimate ? (content.length * 2 + 100) : 50;
        setTimeout(() => {
          this.addCopyButton(bubbleDiv, content);
        }, copyButtonDelay);
      }
      
      messageDiv.appendChild(bubbleDiv);
    }
      // Append to messages container
    this.messagesContainer.appendChild(messageDiv);
      // Smart scroll to bottom using the ScrollToBottomManager if available
    if (this.scrollToBottomManager) {
      // Use the enhanced scroll manager for better UX
      this.scrollToBottomManager.smartAutoScroll();
    } else {
      // Fallback to simple scroll behavior
      this.smartScrollToBottom();
    }
    
    // Note: Message persistence is handled by the persistence manager in handleUnifiedMessage
    // to avoid duplicate saves and ensure proper sidebar synchronization
    
    return messageId;
  }  // Format AI response content with markdown support
  formatAIResponse(content, agentType = 'orchestrator') {
    // Always use the full markdown renderer to ensure consistent styling
    if (window.arzaniRenderer) {
      try {
        console.log('üé® Using markdown renderer for AI response');
        // This ensures all content (including lists, code blocks, headings) 
        // is rendered with proper markdown styling
        return window.arzaniRenderer.renderToHtml(content, agentType);
      } catch (error) {
        console.warn('‚ö†Ô∏è Markdown renderer failed, using fallbacks:', error);
      }
    }
    
    // Fallback: Check if content contains tables and convert them
    if (content.includes('|') && /^\s*\|.*\|/m.test(content)) {
      console.log('üîÑ Converting markdown tables to HTML');
      return window.arzaniRenderer ? window.arzaniRenderer.convertMarkdownTables(content) : content;
    }
    
    // Final fallback: return content with basic markdown processing
    // This handles common markdown elements when the renderer fails
    console.log('‚ö†Ô∏è Using basic markdown fallback');
    return this.basicMarkdownFallback(content);
  }
  
  // Basic markdown fallback function when the renderer is not available
  basicMarkdownFallback(content) {
    // Simple regex replacements for basic markdown elements
    return content
      // Headers
      .replace(/^# (.+)$/gm, '<h1 class="text-3xl font-medium mt-8 mb-4">$1</h1>')
      .replace(/^## (.+)$/gm, '<h2 class="text-2xl font-medium mt-6 mb-3">$1</h2>')
      .replace(/^### (.+)$/gm, '<h3 class="text-xl font-medium mt-5 mb-2">$1</h3>')
      // Lists - using new class names for consistent styling
      .replace(/^- (.+)$/gm, '<li class="message-content-li">$1</li>')
      .replace(/^(\d+)\. (.+)$/gm, '<li class="message-content-li">$2</li>')
      // Wrap lists
      .replace(/(<li class="message-content-li">.*?<\/li>\n)+/gs, (match) => {
        return `<ul class="message-content-ul">${match}</ul>`;
      })
      // Bold and italic
      .replace(/\*\*(.+?)\*\*/g, '<strong class="font-medium text-gray-900">$1</strong>')
      .replace(/\*(.+?)\*/g, '<em class="italic text-gray-700">$1</em>')
      // Code
      .replace(/`(.+?)`/g, '<code class="bg-gray-50 px-1.5 py-0.5 rounded font-mono text-sm">$1</code>')
      // Line breaks
      .replace(/\n/g, '<br>');
  }
  
  // Add copy button to AI messages
  addCopyButton(messageElement, content) {
    // Check if copy button already exists
    if (messageElement.querySelector('.copy-button')) return;
    
    const copyButton = document.createElement('button');
    copyButton.className = 'copy-button';
    copyButton.title = 'Copy message';
    
    copyButton.innerHTML = `
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
      </svg>
    `;
    
    copyButton.addEventListener('click', async (e) => {
      e.stopPropagation();
      try {
        await navigator.clipboard.writeText(content);
        
        // Show copied state
        copyButton.classList.add('copied');
        copyButton.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="20,6 9,17 4,12"></polyline>
          </svg>
        `;
        
        // Reset after 2 seconds
        setTimeout(() => {
          copyButton.classList.remove('copied');
          copyButton.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
            </svg>
          `;
        }, 2000);
        
      } catch (err) {
        console.error('Failed to copy text: ', err);
        
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = content;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Show copied state
        copyButton.classList.add('copied');
        setTimeout(() => {
          copyButton.classList.remove('copied');
        }, 2000);
      }
    });
    
    messageElement.appendChild(copyButton);
  }
  
  
  // Helper function to detect if user is near bottom of chat
  isUserNearBottom(threshold = 50) {
    const container = this.messagesContainer;
    const scrollTop = container.scrollTop;
    const scrollHeight = container.scrollHeight;
    const clientHeight = container.clientHeight;
    
    return (scrollHeight - scrollTop - clientHeight) <= threshold;
  }
  // Smart scroll function that only scrolls when user is at bottom
  smartScrollToBottom() {
    if (this.isUserNearBottom()) {
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
  }
  // Get display name for agents
  getAgentDisplayName(agentType) {
    const names = {
      'broker': 'Broker Agent',
      'legal': 'Legal Agent',
      'finance': 'Finance Agent',
      'orchestrator': 'Orchestrator',
      'default': 'Arzani'
    };
    return names[agentType] || names.default;
  }

  // Update chat context header with conversation info
  updateChatContextHeader(conversationTitle, agentType, messageCount, lastActiveTime) {
    const chatHeader = document.getElementById('chatContextHeader');
    const titleEl = document.getElementById('activeConversationTitle');
    const agentEl = document.getElementById('activeConversationAgent');
    const timeEl = document.getElementById('activeConversationTime');
    const messagesEl = document.getElementById('activeConversationMessages');
    
    if (!chatHeader || !titleEl || !agentEl || !timeEl || !messagesEl) return;
    
    // Show header when conversation is active
    chatHeader.style.display = 'block';
    
    // Update title - use enhanced title generation
    titleEl.textContent = conversationTitle || 'New Conversation';
    
    // Update agent display
    agentEl.textContent = this.getAgentDisplayName(agentType);
    
    // Update time display
    if (lastActiveTime) {
      const timeAgo = this.formatTimeAgo(new Date(lastActiveTime));
      timeEl.textContent = timeAgo;
    } else {
      timeEl.textContent = 'Just started';
    }
    
    // Update message count
    const messageText = messageCount === 1 ? '1 message' : `${messageCount || 0} messages`;
    messagesEl.textContent = messageText;
  }

  // Helper function to format time ago (matching sidebar)
  formatTimeAgo(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffMinutes < 1) return 'Just now';
    if (diffMinutes < 60) return `${diffMinutes}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    });
  }  // Enhanced markdown-aware typewriter animation function with comprehensive stop support
  animateTypewriter(element, text, messageId, shouldAnimate = true, speed = 1, agentType = 'orchestrator') {
    // Debug: Check if markdown renderer is available
    console.log('üéØ Typewriter starting:', {
      hasRenderer: !!window.arzaniRenderer,
      textLength: text.length,
      textPreview: text.substring(0, 100) + '...',
      shouldAnimate
    });    // If shouldAnimate is false, just display the text immediately
    if (!shouldAnimate) {
      // Always use markdown renderer for consistency
      if (window.arzaniRenderer) {        try {
          element.innerHTML = window.arzaniRenderer.renderToHtml(text, agentType);        } catch (error) {
          console.warn('‚ö†Ô∏è Markdown renderer error in immediate display, using plain text:', error);
          element.innerHTML = text;
        }      } else {
        console.warn('‚ö†Ô∏è Markdown renderer not available for immediate display');
        element.innerHTML = text;
      }
      
      // Add copy button immediately for non-animated messages
      const messageElement = element.closest('.message-bubble');
      if (messageElement) {
        this.addCopyButton(messageElement, text);
      }
      
      // Remove cursor if present
      const cursor = element.parentElement.querySelector('.typewriter-cursor');
      if (cursor) {
        cursor.style.display = 'none';
      }
      
      return;
    }

    // Initialize animation state
    let isAborted = false;
    let animationTimeoutId = null;
    element.innerHTML = '';
    element.style.position = 'relative';
    
    // Initialize animation timeouts array if not exists
    if (!this.animationTimeouts) {
      this.animationTimeouts = [];
    }    // Determine if content is markdown and prepare for animation
    const isMarkdown = window.arzaniRenderer && window.arzaniRenderer.isMarkdownContent(text);
    const hasTable = window.arzaniRenderer ? window.arzaniRenderer.hasMarkdownTable(text) : false;
    let renderedHtml = '';
    let textToAnimate = text;
    
    console.log('üîç Content analysis:', {
      isMarkdown,
      hasTable,
      textStart: text.substring(0, 50) + '...'
    });
    
    // For tables, we should always render as markdown without animation
    if (hasTable) {
      console.log('üìä TABLE DETECTED: Skipping character-by-character animation for tables');
      shouldAnimate = false;
    }
    
    if ((isMarkdown || hasTable) && window.arzaniRenderer) {
      console.log('üé® Detected markdown content, preparing for markdown-aware animation');
        // Render markdown to HTML for final display
      try {
        renderedHtml = window.arzaniRenderer.renderToHtml(text, agentType);
        console.log('‚úÖ Markdown rendered successfully');
      } catch (error) {
        console.error('‚ùå Markdown rendering failed:', error);
        // Use fallback table conversion
        if (hasTable) {
          console.log('üîÑ Using fallback table conversion');
          renderedHtml = window.arzaniRenderer ? window.arzaniRenderer.convertMarkdownTables(text) : text;
        } else {
          renderedHtml = text;
        }
      }      // Extract plain text for typewriter effect, preserving structure
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = renderedHtml;
      textToAnimate = tempDiv.textContent || tempDiv.innerText || text;
    } else if ((isMarkdown || hasTable) && !window.arzaniRenderer) {
      console.warn('‚ö†Ô∏è Markdown/table detected but renderer not available, using fallback');
      if (hasTable) {
        renderedHtml = window.arzaniRenderer ? window.arzaniRenderer.convertMarkdownTables(text) : text;
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = renderedHtml;
        textToAnimate = tempDiv.textContent || tempDiv.innerText || text;
      }
    } else {
      console.log('üìù Plain text content, using standard animation');
    }

    // Set up enhanced abort mechanism
    this.currentTypewriterAbort = () => {
      console.log('üõë Markdown-aware typewriter animation aborted');

      isAborted = true;
      
      // Clear any pending animation timeout
      if (animationTimeoutId) {
        clearTimeout(animationTimeoutId);
        animationTimeoutId = null;
      }
      
      // Remove cursor
      const cursor = element.parentElement.querySelector('.typewriter-cursor');
      if (cursor) {
        cursor.remove();
      }
        
      // Always apply final rendering using markdown renderer for consistency
      if (window.arzaniRenderer) {
        try {
          console.log('üé® Applying markdown rendering after abort');
          const finalHtml = window.arzaniRenderer.renderToHtml(text, agentType);
          element.innerHTML = finalHtml;
        } catch (error) {
          console.warn('‚ö†Ô∏è Markdown renderer error after abort, using enhanced fallback:', error);
          // Use our basic markdown fallback for consistent styling
          element.innerHTML = this.basicMarkdownFallback(text);
        }
      } else {
        console.warn('‚ö†Ô∏è Markdown renderer not available after abort, using enhanced fallback');
        // Use our basic markdown fallback for consistent styling
        element.innerHTML = this.basicMarkdownFallback(text);
      }
      
      // Add copy button with original text
      const messageElement = element.closest('.message-bubble');
      if (messageElement) {
        this.addCopyButton(messageElement, text);
      }
      
      console.log('‚úÖ Markdown-aware typewriter animation stopped');
    };

    // Animation variables
    let i = 0;
    let currentDisplayText = '';
    
    const typeNextChar = () => {
      // Check for abort conditions
      if (isAborted || this.shouldStopProcessing) {
        console.log('üõë Markdown typewriter animation stopped during typing');
        
        // Remove cursor
        const cursor = element.parentElement.querySelector('.typewriter-cursor');
        if (cursor) cursor.remove();
          
        // Always use markdown renderer for final content
        if (window.arzaniRenderer) {
          try {
            element.innerHTML = window.arzaniRenderer.renderToHtml(text, agentType);
          } catch (error) {
            console.warn('‚ö†Ô∏è Markdown renderer error after abort, using enhanced fallback:', error);
            element.innerHTML = this.basicMarkdownFallback(text);
          }
        } else {
          console.warn('‚ö†Ô∏è Markdown renderer not available after abort, using enhanced fallback');
          element.innerHTML = this.basicMarkdownFallback(text);
        }
        
        // Add copy button
        const messageElement = element.closest('.message-bubble');
        if (messageElement) {
          this.addCopyButton(messageElement, text);
        }
        
        // Clear the abort mechanism and update UI
        this.currentTypewriterAbort = null;
        this.updateButtonStates();
        return;
      }
        if (i < textToAnimate.length) {
        const char = textToAnimate.charAt(i);
        currentDisplayText += char;
        
        // Update display with current text
        if (isMarkdown) {
          // For markdown content, show progressive text using the markdown renderer
          const progressiveText = text.substring(0, i + 1);
            // Use the markdown renderer for progressive rendering during animation
          if (window.arzaniRenderer) {
            try {
              // Special handling for tables - if we detect partial table rendering, skip it
              if (hasTable && progressiveText.includes('|') && !window.arzaniRenderer.hasMarkdownTable(progressiveText)) {
                // Skip partial table rendering to prevent malformed tables
                element.innerHTML = progressiveText;
              } else {
                const progressiveHtml = window.arzaniRenderer.renderToHtml(progressiveText, agentType);
                element.innerHTML = progressiveHtml;
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Markdown renderer error during progressive animation, using plain text:', error);
              element.innerHTML = progressiveText;
            }          } else {
            // Fallback when renderer not available
            element.innerHTML = progressiveText;
          }
        } else {          
          // Always use the markdown renderer for ALL content types to ensure consistent styling
          if (window.arzaniRenderer) {
            try {
              const progressiveText = text.substring(0, i + 1);
              const progressiveHtml = window.arzaniRenderer.renderToHtml(progressiveText, agentType);
              element.innerHTML = progressiveHtml;
            } catch (error) {
              console.warn('‚ö†Ô∏è Markdown renderer error for content, using enhanced fallback:', error);
              // Fallback with basic markdown processing
              const progressiveText = text.substring(0, i + 1);
              // Use our basic markdown fallback for consistent styling
              element.innerHTML = this.basicMarkdownFallback(progressiveText);
            }
          } else {
            // Legacy character-by-character animation only as final fallback
            if (char === '\n') {
              element.appendChild(document.createElement('br'));
            } else {
              const charSpan = document.createElement('span');
              charSpan.textContent = char;
              charSpan.style.opacity = '0';
              element.appendChild(charSpan);
              
              // Fade in character
              setTimeout(() => {
                if (!isAborted && !this.shouldStopProcessing) {
                  charSpan.style.opacity = '1';
                }
              }, 10);
            }
          }
        }
        
        i++;
        
        // Calculate typing speed with variation (much faster)
        const typingSpeed = speed + (Math.random() * 2 - 1);
        const nextSpeed = Math.max(typingSpeed, 1); // Much faster for markdown
        
        // Schedule next character
        animationTimeoutId = setTimeout(typeNextChar, nextSpeed);
        
        // Track timeout for cleanup
        if (this.animationTimeouts) {
          this.animationTimeouts.push(animationTimeoutId);
        }
      } else {        // Animation completed naturally
        console.log('‚úÖ Markdown-aware typewriter animation completed');
          
        // Always apply final rendering using markdown renderer for consistency
        if (window.arzaniRenderer) {
          try {
            console.log('üé® Applying final markdown rendering');
            const finalHtml = window.arzaniRenderer.renderToHtml(text, agentType);
            element.innerHTML = finalHtml;
          } catch (error) {
            console.warn('‚ö†Ô∏è Markdown renderer error during completion, using enhanced fallback:', error); 
            // Use basic markdown fallback for consistent styling
            element.innerHTML = this.basicMarkdownFallback(text);
          }
        } else {
          console.warn('‚ö†Ô∏è Markdown renderer not available at completion, using enhanced fallback');
          // Use our basic markdown fallback for consistent styling
          element.innerHTML = this.basicMarkdownFallback(text);
        }
        
        // Remove cursor after completion
        const cursor = element.parentElement.querySelector('.typewriter-cursor');
        if (cursor) {
          setTimeout(() => {
            cursor.remove();
          }, 500);
        }
        
        // Add copy button
        const messageElement = element.closest('.message-bubble');
        if (messageElement) {
          this.addCopyButton(messageElement, text);
        }
        
        // Clear abort mechanism and update UI
        this.currentTypewriterAbort = null;
        this.updateButtonStates();
        
        // Smart scroll when complete
        setTimeout(() => {
          if (!this.shouldStopProcessing) {
            this.smartScrollToBottom();
          }
        }, 40);
      }
    };
    
    // Start the animation
    typeNextChar();
  }
  // Remove message from conversation area
  removeConversationMessage(messageId) {
    const message = document.getElementById(messageId);
    if (message) {
      message.remove();
    }
  }
  // Clear current conversation and reset animation tracking
  clearCurrentConversation() {
    this.messagesContainer.innerHTML = '';
    this.chatHistory = [];
    this.conversationStarted = false;
    this.currentConversationId = null;
    this.isLoadingHistory = false;
    this.animatedMessages.clear(); // Reset animation tracking
    console.log('üßπ Cleared conversation and reset animation tracking');
    
    // Hide chat context header when no conversation is active
    const chatHeader = document.getElementById('chatContextHeader');
    if (chatHeader) {
      chatHeader.style.display = 'none';
    }
  }// Transition to conversational layout after first message with persistence integration
  async transitionToConversationLayout() {
    if (this.conversationStarted) return;
    
    this.conversationStarted = true;
    
    // Create database session if persistence is available
    if (this.persistenceManager && !this.persistenceManager.hasActiveSession()) {
      try {
        console.log('üîÑ Creating new A2A session for conversation...');
        const session = await this.persistenceManager.createSession(this.selectedAgent);
        console.log(`‚úÖ A2A session created: ${session.id}`);
        
        // Store session ID for reference
        this.currentConversationId = session.id;
        
        // Update sidebar to refresh conversation list
        if (window.arzaniModernSidebar) {
          await window.arzaniModernSidebar.refresh();
          
          // Set the new conversation as active in the sidebar
          setTimeout(() => {
            window.arzaniModernSidebar.currentConversationId = session.id;
            this.persistenceManager.updateActiveConversationUI(session.id);
          }, 500);
        }
      } catch (error) {
        console.error('‚ùå Failed to create A2A session:', error);
        // Continue without persistence - don't block the conversation
      }
    }
    
    // Only apply layout transition if this is the initial page load
    // When switching conversations, we want to stay in conversation mode
    if (this.isInitialPageLoad) {
      // Hide main heading and form container with animation
      this.mainHeading.style.animation = 'slideInFromTop 0.6s ease-out reverse';
      this.mainFormContainer.style.animation = 'slideInFromTop 0.6s ease-out reverse';
      
      setTimeout(() => {
        this.mainHeading.style.display = 'none';
        this.mainFormContainer.style.display = 'none';
        
        // Apply conversation mode class to content body
        const contentBody = document.querySelector('.content-body');
        if (contentBody) {
          contentBody.classList.add('conversation-mode');
        }
        
        // Show conversation area and bottom input
        this.conversationArea.classList.remove('hidden');
        this.bottomInputArea.classList.remove('hidden');
        
        // Animate in conversation area
        this.conversationArea.style.animation = 'slideInFromTop 0.6s ease-out';
        this.bottomInputArea.style.animation = 'slideInFromBottom 0.6s ease-out';
        
        // Focus on bottom input
        this.bottomChatInput.focus();
      }, 300);
      
      // Mark that initial page load is complete
      this.isInitialPageLoad = false;
    } else {
      // For conversation switches, just ensure conversation mode is active
      const contentBody = document.querySelector('.content-body');
      if (contentBody && !contentBody.classList.contains('conversation-mode')) {
        contentBody.classList.add('conversation-mode');
        this.mainHeading.style.display = 'none';
        this.mainFormContainer.style.display = 'none';
        this.conversationArea.classList.remove('hidden');
        this.bottomInputArea.classList.remove('hidden');
      }
    }
  }  // Clear conversation and optionally return to main layout
  clearConversation(returnToMainLayout = true) {
    if (!this.conversationStarted) return;
    
    // Clear messages
    this.messagesContainer.innerHTML = '';
    this.chatHistory = [];
    
    // Reset conversation state
    this.conversationStarted = false;
    
    if (returnToMainLayout) {
      // Hide conversation area and bottom input with animation
      this.conversationArea.style.animation = 'slideInFromTop 0.6s ease-out reverse';
      this.bottomInputArea.style.animation = 'slideInFromBottom 0.6s ease-out reverse';
      
      setTimeout(() => {
        this.conversationArea.classList.add('hidden');
        this.bottomInputArea.classList.add('hidden');
        
        // Remove conversation mode class from content body
        const contentBody = document.querySelector('.content-body');
        if (contentBody) {
          contentBody.classList.remove('conversation-mode');
        }
        
        // Show main heading and form container
        this.mainHeading.style.display = 'block';
        this.mainFormContainer.style.display = 'block';
        
        // Animate in main elements
        this.mainHeading.style.animation = 'slideInFromTop 0.6s ease-out';
        this.mainFormContainer.style.animation = 'slideInFromTop 0.6s ease-out';
        
        // Focus on main input
        this.input.focus();
      }, 300);
    } else {      // Stay in conversation mode, just clear the messages
      // Keep conversation area visible for new chat
    }
  }

  // Force transition to conversational layout (used when selecting existing conversations)
  forceTransitionToConversationLayout() {
    console.log('üîÑ Forcing transition to conversation layout...');
    
    // Hide main heading and form container immediately
    this.mainHeading.style.display = 'none';
    this.mainFormContainer.style.display = 'none';
    
    // Apply conversation mode class to content body
    const contentBody = document.querySelector('.content-body');
    if (contentBody) {
      contentBody.classList.add('conversation-mode');
    }
    
    // Show conversation area and bottom input
    this.conversationArea.classList.remove('hidden');
    this.bottomInputArea.classList.remove('hidden');
    
    // Ensure conversation started flag is set
    this.conversationStarted = true;
    
    // Mark that initial page load is complete
    this.isInitialPageLoad = false;
    
    console.log('‚úÖ Successfully transitioned to conversation layout');
  }

  // Update credits display
  updateCreditsDisplay() {
    if (this.creditsRemaining) {
      this.creditsRemaining.textContent = this.credits;
    }
  }

  // Chat History Management
  getChatHistory() {
    return this.chatHistory;
  }
    clearChatHistory() {
    this.chatHistory = [];
    
    // Clear visual chat in conversation area
    this.messagesContainer.innerHTML = '';
    
    console.log('Chat history cleared');
  }
  exportChatHistory() {
    const history = this.chatHistory.map(item => ({
      timestamp: item.timestamp.toISOString(),
      sender: item.sender,
      agent: item.agent || 'user',
      message: item.message
    }));
    
    const blob = new Blob([JSON.stringify(history, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `arzani-chat-history-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.addConversationMessage('üíæ Chat history exported successfully!', 'assistant');
  }
  
  // Keyboard shortcuts
  initializeKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + K to focus chat input
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        if (this.conversationStarted) {
          this.bottomChatInput.focus();
        } else {
          this.input.focus();
        }
      }
      
      // Ctrl/Cmd + Shift + C to clear chat
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
        e.preventDefault();
        this.clearConversation();
      }
      
      // Ctrl + Shift + D to test disclaimer (for debugging)
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        e.preventDefault();
        console.log('Debug: Testing disclaimer popup');
        this.testShowDisclaimer();
      }
    });
  }  /**
   * Save message to database through persistence manager
   */
  async saveMessageToDatabase(content, sender) {
    try {
      if (!this.persistenceManager || !this.persistenceManager.hasActiveSession()) {
        return;
      }

      const agentType = sender === 'user' ? null : this.selectedAgent;
      await this.persistenceManager.saveMessage(content, sender, agentType);
      
      console.log(`‚úÖ Message saved to database: ${sender}`);
    } catch (error) {
      console.error('‚ùå Failed to save message to database:', error);
      // Don't throw - allow conversation to continue
    }
  }

  /**
   * Update message in conversation area
   */
  updateConversationMessage(messageId, newContent) {
    const messageElement = document.getElementById(messageId);
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble');
      if (contentElement) {
        contentElement.innerHTML = newContent;
      }
    }
  }

  /**
   * Generate UUID for task IDs
   */
  generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  /**
   * Generate request ID for A2A protocol
   */
  generateRequestId() {
    return `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get authentication token from various sources
   */
  getAuthToken() {
    // Try localStorage first
    let token = localStorage.getItem('authToken') || localStorage.getItem('token');
    
    if (token) return token;
    
    // Try meta tag
    const metaToken = document.querySelector('meta[name="auth-token"]')?.content;
    if (metaToken) return metaToken;
    
    // Try session storage
    token = sessionStorage.getItem('authToken') || sessionStorage.getItem('token');
    if (token) return token;
    
    // Try cookie
    const cookieMatch = document.cookie.match(/(?:^|; )(?:authToken|token)=([^;]*)/);
    if (cookieMatch) return cookieMatch[1];
    
    return null;
  }

  /**
   * Switch to conversation and sync with sidebar
   */
  async switchToConversation(conversationId) {
    try {
      // Use persistence manager if available for better integration
      if (this.persistenceManager) {
        await this.persistenceManager.syncWithMainChat(conversationId);
        return;
      }

      // Fallback to original method
      await this.loadConversation(conversationId);
    } catch (error) {
      console.error('Error switching to conversation:', error);
      this.addConversationMessage('‚ùå Failed to load conversation. Please try again.', 'assistant');
    }
  }

  // Enhanced retry functionality for conversation area
  addRetryMessageToConversation(originalMessage) {
    const retryId = 'conv-retry-' + Date.now();
    const retryDiv = document.createElement('div');
    retryDiv.id = retryId;
    retryDiv.className = 'message-fade-in flex justify-center my-2';
    
    const retryButton = document.createElement('button');
    retryButton.className = 'bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 text-sm flex items-center space-x-2';
    retryButton.innerHTML = `
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
      </svg>
      <span>Retry with ${this.selectedAgent}</span>
    `;
    
    retryButton.addEventListener('click', () => {
      this.removeConversationMessage(retryId);
      this.bottomChatInput.value = originalMessage;
      this.handleBottomUserMessage();
    });
    
    retryDiv.appendChild(retryButton);
    
    // Append to messages container    this.messagesContainer.appendChild(retryDiv);
    
    // Smart scroll to bottom
    this.smartScrollToBottom();
    
    return retryId;
  }

  // Enhanced retry functionality
  addRetryMessage(originalMessage) {
    const retryId = 'retry-' + Date.now();
    const retryDiv = document.createElement('div');
    retryDiv.id = retryId;
    retryDiv.className = 'message-fade-in flex justify-center my-2';
    
    const retryButton = document.createElement('button');
    retryButton.className = 'bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 text-sm flex items-center space-x-2';
    retryButton.innerHTML = `
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
      </svg>
      <span>Retry with ${this.selectedAgent}</span>
    `;
    
    retryButton.addEventListener('click', () => {
      this.removeMessage(retryId);
      this.input.value = originalMessage;
      this.handleUserMessage();
    });
    
    retryDiv.appendChild(retryButton);
    
    // Append to chat messages container
    this.chatMessages.appendChild(retryDiv);
    
    // Scroll to bottom
    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
    
    return retryId;
  }

  // Auto-agent switching for failed requests
  async tryAlternativeAgent(originalMessage) {
    const availableAgents = Object.keys(this.agentUrls).filter(agent => 
      agent !== this.selectedAgent && this.agentStatus[agent] === 'online'
    );
    
    if (availableAgents.length > 0) {
      const alternativeAgent = availableAgents[0];
      this.addMessage(`üîÑ Switching to ${alternativeAgent} agent...`, 'assistant');
      
      const originalAgent = this.selectedAgent;
      this.selectedAgent = alternativeAgent;
      this.updateSelectedAgentUI();
      
      try {
        const response = await this.sendToA2A(originalMessage);
        this.addMessage(response, 'assistant');
        this.addMessage(`‚úÖ Successfully handled by ${alternativeAgent} agent`, 'assistant');
      } catch (error) {
        // Revert to original agent
        this.selectedAgent = originalAgent;
        this.updateSelectedAgentUI();
        this.addMessage(`‚ùå ${alternativeAgent} agent also failed. Please try again later.`, 'assistant');
      }
    }
  }
  generateSessionId() {
    return 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  }

  generateRequestId() {
    return Date.now().toString();
  }
  generateUUID() {
    // Generate a UUID v4 (random)
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Sidebar Integration Methods
  clearCurrentConversation() {
    // Alias for existing clearConversation method
    this.clearConversation();
  }

  showWelcomeMessage() {
    if (this.conversationStarted) {
      // Clear messages first
      this.messagesContainer.innerHTML = '';
      
      // Add welcome message
      const welcomeMessage = `
        <div class="message-fade-in flex items-start space-x-3 mb-4">
          <div class="flex-shrink-0">
            <div class="w-8 h-8 rounded-full bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center">
              <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-3.582 8-8 8a9.863 9.863 0 01-4.906-1.289L3 21l1.516-5.346A9.863 9.863 0 013 12c0-4.418 3.582-8 8-8s8 3.582 8 8z"></path>
              </svg>
            </div>
          </div>
          <div class="flex-1 bg-gray-100 p-3 rounded-lg rounded-tl-none">
            <p class="text-gray-800">Welcome to Arzani! I'm here to help you with any questions you might have. How can I assist you today?</p>
          </div>
        </div>
      `;
      
      this.messagesContainer.innerHTML = welcomeMessage;
    } else {
      // If not in conversation mode, transition to it first
      this.transitionToConversationLayout();
      setTimeout(() => {
        this.showWelcomeMessage();
      }, 500);
    }
  }

  setCurrentConversation(conversationId) {
    this.currentConversationId = conversationId;
    console.log('Set current conversation ID:', conversationId);
  }

  async loadConversationById(conversationId) {
    try {
      this.setCurrentConversation(conversationId);
      
      // Get auth token
      const token = localStorage.getItem('token') || 
                    document.querySelector('meta[name="auth-token"]')?.content;
      
      if (!token) {
        console.warn('No auth token available for loading conversation');
        this.showWelcomeMessage();
        return;
      }
        // Fetch conversation from API
      const response = await fetch(`/api/threads/${conversationId}/messages`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        if (response.status === 403) {
          console.warn('Access denied to conversation:', conversationId);
          this.showWelcomeMessage();
          return;
        }
        throw new Error(`Failed to load conversation: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load conversation');
      }        // Clear current messages
      this.messagesContainer.innerHTML = '';
      
      // Set flag to indicate we're loading previous conversation (no animations)
      this.isLoadingHistory = true;
      
      // Always ensure we're in conversation mode when loading a conversation
      this.forceTransitionToConversationLayout();      // Display messages
      if (data.messages && data.messages.length > 0) {
        console.log('üìú Loading', data.messages.length, 'previous messages without animations');
        data.messages.forEach(message => {
          const senderType = message.sender_id === -1 || message.is_system_message ? 'assistant' : 'user';
          this.addConversationMessage(message.content, senderType, false, message.created_at, true); // Disable animation for previous conversations
        });
      } else {
        this.showWelcomeMessageInConversation();
      }
      
      // Reset flag after loading
      this.isLoadingHistory = false;
        console.log('Loaded conversation:', conversationId, 'with', data.messages?.length || 0, 'messages');
      
    } catch (error) {
      console.error('Error loading conversation:', error);
      this.showWelcomeMessage();
    }  }
}

// Initialize collapsible agent panel
function initializeAgentPanel() {
  const compactView = document.getElementById('agentStatusCompact');
  const expandedView = document.getElementById('agentStatusExpanded');
  const toggleIcon = document.getElementById('agentPanelToggle');
  
  if (!compactView || !expandedView || !toggleIcon) return;
  
  let isExpanded = false;
    compactView.addEventListener('click', () => {
    isExpanded = !isExpanded;
    
    if (isExpanded) {
      expandedView.style.display = 'block';
      toggleIcon.classList.add('expanded');
    } else {
      expandedView.style.display = 'none';
      toggleIcon.classList.remove('expanded');
    }
  });
  
  // Initialize tooltips for agent items
  initializeAgentTooltips();
  
  // Update active agent display
  function updateActiveAgentDisplay(agentType) {
    const activeAgentIcon = document.getElementById('activeAgentIcon');
    const activeAgentName = document.getElementById('activeAgentName');
    const activeAgentStatus = document.getElementById('activeAgentStatus');
    
    const agentNames = {
      'orchestrator': 'Orchestrator',
      'broker': 'Broker Agent',
      'legal': 'Legal Agent',
      'finance': 'Finance Agent'
    };    const iconPaths = {
      'broker': '/figma%20design%20exports/images/3dicons-calculator-dynamic-premium.png',
      'legal': '/figma%20design%20exports/images/3dicons-folder-dynamic-premium.png',
      'finance': '/figma%20design%20exports/images/3dicons-pound-dynamic-premium.png',
      'orchestrator': '/figma%20design%20exports/images/3dicons-megaphone-dynamic-premium.png'
    };
    
    if (activeAgentIcon) {
      // Update with the appropriate image
      activeAgentIcon.innerHTML = `<img src="${iconPaths[agentType] || iconPaths['orchestrator']}" alt="${agentType}" width="24" height="24">`;
    }
    
    if (activeAgentName) activeAgentName.textContent = agentNames[agentType] || 'Orchestrator';
      // Update agent items in expanded view
    document.querySelectorAll('.agent-item').forEach(item => {
      const agent = item.getAttribute('data-agent');
      if (agent === agentType) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
      // Remove inactive class to prevent greying out
      item.classList.remove('inactive');
    });
  }
  
  // Listen for agent changes
  if (window.arzaniClient) {
    const originalUpdateButtonStates = window.arzaniClient.updateButtonStates;
    window.arzaniClient.updateButtonStates = function() {
      originalUpdateButtonStates.call(this);
      updateActiveAgentDisplay(this.selectedAgent);
    };
    
    // Initial update
    updateActiveAgentDisplay(window.arzaniClient.selectedAgent);
  }
}

// ThinkingPanel class for detailed AI thinking process visualization
class ThinkingPanel {  constructor(agentType = 'orchestrator', panelId = null) {
    this.agentType = agentType;
    this.panelId = panelId || 'thinking-' + Date.now();
    this.element = null;
    this.thoughtsList = null;
    this.isExpanded = true; // Start expanded so users can see the thinking process
    this.thoughts = [];
    this.currentThoughtIndex = 0;
    
    this.agentConfig = {
      'orchestrator': {
        name: 'Orchestrator',
        icon: 'üß†',
        color: '#3b82f6',
        thinkingSteps: [
          'Analyzing user query for intent classification...',
          'Determining which specialist agents to consult...',
          'Preparing sequential agent consultation...',
          'Coordinating responses from specialist agents...'
        ]
      },
      'broker': {
        name: 'Broker Agent',
        icon: 'üìä',
        color: '#10b981',
        thinkingSteps: [
          'Analyzing business valuation request...',
          'Searching for comparable market data...',
          'Calculating EBITDA multiples...',
          'Generating structured valuation report...'
        ]
      },
      'legal': {
        name: 'Legal Agent',
        icon: '‚öñÔ∏è',
        color: '#8b5cf6',
        thinkingSteps: [
          'Reviewing legal requirements and compliance...',
          'Analyzing contract terms and conditions...',
          'Checking UK regulatory frameworks...',
          'Preparing legal documentation...'
        ]
      },
      'finance': {
        name: 'Finance Agent',
        icon: 'üí∞',
        color: '#f59e0b',
        thinkingSteps: [
          'Analyzing financial data and metrics...',
          'Calculating tax implications...',
          'Evaluating cash flow scenarios...',
          'Preparing detailed financial analysis...'
        ]
      }
    };
    
    this.createPanel();
  }
    createPanel() {
    const config = this.agentConfig[this.agentType] || this.agentConfig['orchestrator'];
    
    this.element = document.createElement('div');
    this.element.className = 'thinking-panel';
    this.element.id = this.panelId;
    this.element.setAttribute('data-agent', this.agentType);
      this.element.innerHTML = `
      <div class="thinking-header" onclick="window.toggleThinkingPanel('${this.panelId}')">
        <div class="thinking-title">
          <div class="thinking-icon">${config.icon}</div>
          <span>${config.name} is thinking...</span>
        </div>
        <div class="thinking-toggle expanded">
          <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 12l-4-4h8l-4 4z"/>
          </svg>
        </div>
      </div>
      <div class="thinking-content expanded">
        <ul class="thinking-list"></ul>
      </div>
    `;
    
    this.thoughtsList = this.element.querySelector('.thinking-list');
    
    // Auto-append to messages container
    this.appendToMessagesContainer();
    
    // Initialize with default thinking steps
    this.initializeDefaultSteps();
  }
  appendToMessagesContainer() {
    // Find the messages container and append the thinking panel
    let messagesContainer = document.getElementById('messagesContainer');
    console.log('üîç Looking for messagesContainer:', messagesContainer ? 'FOUND' : 'NOT FOUND');
    
    // Fallback: try alternative container selection methods
    if (!messagesContainer) {
      console.log('üîÑ Trying alternative container selection methods...');
      
      // Try querySelector with class
      messagesContainer = document.querySelector('.messages-container');
      if (messagesContainer) {
        console.log('‚úÖ Found messages container via class selector');
      } else {
        // Try finding by aria-label or role
        messagesContainer = document.querySelector('[role="log"], [aria-label*="message"], .conversation-area');
        if (messagesContainer) {
          console.log('‚úÖ Found messages container via accessibility attributes');
        } else {
          // Last resort: look for any container that might hold messages
          const bodyElement = document.querySelector('.content-body');
          if (bodyElement) {
            messagesContainer = bodyElement;
            console.log('‚úÖ Using content-body as fallback container');
          }
        }
      }
    }
    
    if (messagesContainer) {
      messagesContainer.appendChild(this.element);
      
      // Auto-scroll to show the thinking panel
      setTimeout(() => {
        this.element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
      
      console.log(`‚úÖ ThinkingPanel (${this.agentType}) appended to messages container`);
    } else {
      console.warn('‚ùå Messages container not found - ThinkingPanel not displayed');
      
      // Debug: List all containers that might be the target
      const possibleContainers = [
        'messagesContainer',
        'messages-container', 
        'chatMessages',
        'conversation-area',
        'conversationArea'
      ];
      
      console.log('üîç Available containers:');
      possibleContainers.forEach(id => {
        const container = document.getElementById(id);
        console.log(`  - ${id}: ${container ? 'EXISTS' : 'NOT FOUND'}`);
      });
      
      // Show all elements with common container classes
      const containerClasses = ['.content-body', '.conversation-area', '.chat-container', '.messages'];
      containerClasses.forEach(className => {
        const elements = document.querySelectorAll(className);
        console.log(`  - ${className}: ${elements.length} elements found`);
      });
    }
  }
  
  initializeDefaultSteps() {
    const config = this.agentConfig[this.agentType] || this.agentConfig['orchestrator'];
    config.thinkingSteps.forEach((step, index) => {
      this.addThought(step, false, index * 500); // Staggered animation
    });
  }
    addThought(text, isCompleted = false, delay = 0) {
    setTimeout(() => {
      const thoughtItem = document.createElement('li');
      thoughtItem.className = `thinking-item ${isCompleted ? '' : 'current'}`;
      
      thoughtItem.innerHTML = `
        <div class="thinking-step ${isCompleted ? 'completed' : ''}"></div>
        <div class="thinking-text">${text}</div>
      `;
      
      this.thoughtsList.appendChild(thoughtItem);
      this.thoughts.push({ text, isCompleted, element: thoughtItem });
      
      // Mark previous thought as completed
      if (this.thoughts.length > 1 && !isCompleted) {
        const prevThought = this.thoughts[this.thoughts.length - 2];
        prevThought.element.classList.remove('current');
        prevThought.element.querySelector('.thinking-step').classList.add('completed');
      }
    }, delay);
  }
  
  // Clear all thoughts from the panel
  clearThoughts() {
    this.thoughtsList.innerHTML = '';
    this.thoughts = [];
    this.currentThoughtIndex = 0;
    console.log('üßπ Cleared all thoughts from ThinkingPanel');
  }
  
  // Update panel with server-provided thinking data
  updateWithServerData(serverThoughts) {
    if (!serverThoughts || !Array.isArray(serverThoughts)) {
      console.warn('‚ö†Ô∏è Invalid server thoughts data:', serverThoughts);
      return;
    }
    
    console.log(`üîÑ Updating ThinkingPanel with ${serverThoughts.length} server thoughts`);
    
    // Clear existing thoughts
    this.clearThoughts();
    
    // Add each server thought with proper timing
    serverThoughts.forEach((thought, index) => {
      const thoughtText = typeof thought === 'string' ? thought : (thought.text || thought);
      const isCompleted = typeof thought === 'object' ? thought.isCompleted : false;
      
      this.addThought(thoughtText, isCompleted, index * 200);
    });
  }
  
  completeCurrentThought() {
    if (this.currentThoughtIndex < this.thoughts.length) {
      const thought = this.thoughts[this.currentThoughtIndex];
      thought.element.classList.remove('current');
      thought.element.querySelector('.thinking-step').classList.add('completed');
      thought.isCompleted = true;
      this.currentThoughtIndex++;
    }
  }
  
  completeAll() {
    this.thoughts.forEach(thought => {
      thought.element.classList.remove('current');
      thought.element.querySelector('.thinking-step').classList.add('completed');
      thought.isCompleted = true;
    });
    
    // Add final completion thought
    setTimeout(() => {
      const config = this.agentConfig[this.agentType] || this.agentConfig['orchestrator'];
      this.addThought(`${config.name} analysis complete!`, true);
    }, 300);
  }
  
  getElement() {
    return this.element;
  }
  
  remove() {
    if (this.element && this.element.parentNode) {
      this.element.remove();
    }
  }
  
  toggle() {
    this.isExpanded = !this.isExpanded;
    const content = this.element.querySelector('.thinking-content');
    const toggle = this.element.querySelector('.thinking-toggle');
    
    if (this.isExpanded) {
      content.classList.add('expanded');
      toggle.classList.add('expanded');
    } else {
      content.classList.remove('expanded');
      toggle.classList.remove('expanded');
    }
  }
}

// Global function to toggle thinking panels
window.toggleThinkingPanel = function(panelId) {
  const panel = document.getElementById(panelId);
  if (panel && panel.thinkingPanelInstance) {
    panel.thinkingPanelInstance.toggle();
  }
};

// Agent thinking animation class
class AgentThinkingAnimation {
  constructor() {
    this.activeAgentIcon = document.getElementById('activeAgentIcon');
    this.activeAgentName = document.getElementById('activeAgentName');
    this.agentNames = ['broker', 'legal', 'finance'];
    this.animationInterval = null;
    this.originalIconHTML = '';
    this.originalNameContent = '';    // Define icon paths for the 3D icons
    this.iconPaths = {
      'broker': '/figma%20design%20exports/images/3dicons-calculator-dynamic-premium.png',
      'legal': '/figma%20design%20exports/images/3dicons-folder-dynamic-premium.png',
      'finance': '/figma%20design%20exports/images/3dicons-pound-dynamic-premium.png',
      'orchestrator': '/figma%20design%20exports/images/3dicons-megaphone-dynamic-premium.png'
    };
  }
    // Create ThinkingPanel instead of just animation
  start(agentType = 'orchestrator', panelId = null) {
    console.log(`üéØ [AGENT-THINKING] Creating ThinkingPanel for agent: ${agentType}`);
    
    try {
      const thinkingPanel = new ThinkingPanel(agentType, panelId);
      
      // Store reference for toggle functionality
      if (thinkingPanel && thinkingPanel.element) {
        thinkingPanel.element.thinkingPanelInstance = thinkingPanel;
        console.log(`‚úÖ [AGENT-THINKING] ThinkingPanel created successfully for ${agentType}`);
      } else {
        console.error(`‚ùå [AGENT-THINKING] ThinkingPanel creation failed - no element created`);
        return null;
      }
      
      return thinkingPanel;
    } catch (error) {
      console.error(`‚ùå [AGENT-THINKING] Error creating ThinkingPanel:`, error);
      return null;
    }
  }
    // Legacy method for compatibility
  remove() {
    // This will be handled by ThinkingPanel.remove()
  }
  
  // Start the legacy icon animation (renamed to avoid conflict)
  startIconAnimation() {
    if (this.animationInterval) return; // Already running
    
    // Save original state
    this.originalIconHTML = this.activeAgentIcon.innerHTML;
    this.originalNameContent = this.activeAgentName.textContent;
    
    // Add animation class to the container
    this.activeAgentIcon.classList.add('agent-thinking-animation');
    this.activeAgentName.style.animation = 'agentNameFade 1.5s ease-in-out infinite';
    
    // Start switching between agents
    this.animationInterval = setInterval(() => {
      const randomAgent = this.agentNames[Math.floor(Math.random() * this.agentNames.length)];
      
      // Update the icon with the corresponding image
      this.activeAgentIcon.innerHTML = `<img src="${this.iconPaths[randomAgent]}" alt="${randomAgent}" width="24" height="24">`;
      
      // Update the agent name
      this.activeAgentName.textContent = this.getAgentName(randomAgent);
    }, 1500); // Switch every 1.5 seconds
  }
  
  // Stop the animation
  stop() {
    if (!this.animationInterval) return; // Not running
    
    clearInterval(this.animationInterval);
    this.animationInterval = null;
    
    // Reset to original state
    this.activeAgentIcon.classList.remove('agent-thinking-animation');
    this.activeAgentName.style.animation = 'none';
    
    // Restore original HTML content and name
    this.activeAgentIcon.innerHTML = this.originalIconHTML;
    this.activeAgentName.textContent = this.originalNameContent;
  }
  
  // Get display name for each agent type
  getAgentName(agentType) {
    switch(agentType) {
      case 'broker': return 'Broker Agent';
      case 'legal': return 'Legal Agent';
      case 'finance': return 'Finance Agent';
      default: return 'Orchestrator';
    }  }
}

// Initialize agent tooltips with improved stability
function initializeAgentTooltips() {
  const agentItems = document.querySelectorAll('.agent-item[data-tooltip]');
  let currentTooltip = null;
  let tooltipTimeout = null;
  let isMouseOverTooltip = false;
  
  // Helper function to safely remove tooltip
  function removeTooltip() {
    if (currentTooltip) {
      currentTooltip.classList.remove('visible');
      setTimeout(() => {
        if (currentTooltip && currentTooltip.parentNode) {
          currentTooltip.remove();
        }
        currentTooltip = null;
      }, 200);
    }
  }
  
  // Helper function to clear any pending tooltip removal
  function clearTooltipTimeout() {
    if (tooltipTimeout) {
      clearTimeout(tooltipTimeout);
      tooltipTimeout = null;
    }
  }
  
  agentItems.forEach(item => {
    item.addEventListener('mouseenter', (e) => {
      clearTooltipTimeout();
      
      // Remove any existing tooltip
      if (currentTooltip) {
        removeTooltip();
      }
      
      const tooltipText = item.getAttribute('data-tooltip');
      if (!tooltipText) return;
      
      // Small delay to ensure stable hover
      setTimeout(() => {
        // Double-check that we're still hovering over the item
        if (!item.matches(':hover')) return;
        
        // Create tooltip element
        const tooltip = document.createElement('div');
        tooltip.className = 'agent-tooltip';
        tooltip.textContent = tooltipText;
        
        // Add mouse events to tooltip itself
        tooltip.addEventListener('mouseenter', () => {
          isMouseOverTooltip = true;
          clearTooltipTimeout();
        });
        
        tooltip.addEventListener('mouseleave', () => {
          isMouseOverTooltip = false;
          tooltipTimeout = setTimeout(() => {
            if (!isMouseOverTooltip) {
              removeTooltip();
            }
          }, 100);
        });
        
        // Add to body
        document.body.appendChild(tooltip);
        currentTooltip = tooltip;
        
        // Position tooltip with more reliable calculation
        requestAnimationFrame(() => {
          const rect = item.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          
          // Position below the item
          let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
          let top = rect.bottom + 15; // Increased gap for better stability
          
          // Keep tooltip within viewport horizontally
          const padding = 10;
          if (left < padding) left = padding;
          if (left + tooltipRect.width > window.innerWidth - padding) {
            left = window.innerWidth - tooltipRect.width - padding;
          }
          
          // Keep tooltip within viewport vertically
          if (top + tooltipRect.height > window.innerHeight - padding) {
            top = rect.top - tooltipRect.height - 15;
            // Update arrow direction for above positioning
            tooltip.classList.add('tooltip-above');
          }
          
          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
          
          // Show tooltip with animation
          setTimeout(() => {
            if (tooltip.parentNode) {
              tooltip.classList.add('visible');
            }
          }, 50);
        });
      }, 100); // Small delay for stability
    });
    
    item.addEventListener('mouseleave', (e) => {
      // Only remove tooltip if not moving to the tooltip itself
      tooltipTimeout = setTimeout(() => {
        if (!isMouseOverTooltip) {
          removeTooltip();
        }
      }, 150);
    });
  });
  
  // Global cleanup on page unload
  window.addEventListener('beforeunload', () => {
    clearTooltipTimeout();
    if (currentTooltip) {
      currentTooltip.remove();
    }
  });
}

// Initialize the A2A client when the page loads
document.addEventListener('DOMContentLoaded', () => {
  window.arzaniClient = new ArzaniA2AClient();
  
  // Initialize collapsible agent panel
  initializeAgentPanel();
  
  // Set up message persistence if the persistence module is available
  if (typeof setupMessagePersistence === 'function') {
    setupMessagePersistence(window.arzaniClient);
    console.log('Message persistence enabled for AI conversations');
  } else {
    console.warn('Message persistence module not loaded - messages will not be saved to database');
  }
  
  // Initialize persistence manager and ensure session is ready for conversations
  if (window.arzaniClient.persistenceManager) {
    // Check if there's an active session, if not prepare to create one on first message
    setTimeout(async () => {
      try {
        if (!window.arzaniClient.persistenceManager.hasActiveSession()) {
          console.log('üìã No active session found on load - will create one on first message');
        } else {
          console.log('‚úÖ Active session already exists');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error checking session status:', error);
      }
    }, 1000);
  }
    // Create chat history interface object for onclick handlers
  window.arzaniChat = {
    refreshChatHistory: function() {
      console.log('Refreshing chat history via sidebar...');
      // Use sidebar refresh to avoid duplicate API calls
      if (window.arzaniModernSidebar && typeof window.arzaniModernSidebar.refresh === 'function') {
        window.arzaniModernSidebar.refresh(); // This is debounced
      } else if (window.arzaniClient && typeof window.arzaniClient.loadChatHistory === 'function') {
        // Fallback for when sidebar is not available
        console.log('Sidebar not available, using direct refresh...');
        window.arzaniClient.loadChatHistory();
      } else {
        console.warn('Chat history refresh not available - neither sidebar nor client initialized');
      }
    },
      showAllHistory: function() {
      console.log('Showing all chat history via sidebar...');
      // Use sidebar refresh for consistency
      if (window.arzaniModernSidebar && typeof window.arzaniModernSidebar.refresh === 'function') {
        window.arzaniModernSidebar.refresh(); // This is debounced
      } else if (window.arzaniClient && typeof window.arzaniClient.loadChatHistory === 'function') {
        // Fallback for when sidebar is not available - keep the original complex logic
        console.log('Sidebar not available, using direct refresh with display override...');
        // Temporarily override the display method to show all conversations
        const originalDisplayMethod = window.arzaniClient.displayChatHistory;
        
        window.arzaniClient.displayChatHistory = function(conversations) {
          // Find the history container or create it
          let historyContainer = document.querySelector('.chat-history-container');
          if (!historyContainer) {
            historyContainer = this.createHistoryContainer();
          }

          // Clear existing history
          historyContainer.innerHTML = `
            <div class="flex items-center justify-between mb-3 px-3">
              <h4 class="text-sm font-medium text-gray-800">All Chats (${conversations.length})</h4>
              <div class="flex gap-1">
                <button class="text-xs text-gray-500 hover:text-gray-700 transition-colors" onclick="window.arzaniChat.refreshChatHistory()">
                  <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"/>
                  </svg>
                </button>
                <button class="text-xs text-gray-500 hover:text-gray-700 transition-colors" onclick="window.arzaniChat.showLimitedHistory()">
                  <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"/>
                  </svg>
                </button>
              </div>
            </div>
          `;

          if (!conversations || conversations.length === 0) {
            const emptyState = document.createElement('div');
            emptyState.className = 'text-center text-gray-500 text-xs py-4 px-3';
            emptyState.innerHTML = `
              <svg class="w-8 h-8 mx-auto mb-2 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clip-rule="evenodd"/>
              </svg>
              <p>No chat history yet</p>
              <p class="text-gray-400">Start a conversation to see it here</p>
            `;
            historyContainer.appendChild(emptyState);
            return;
          }

          // Sort conversations by updated_at (newest first)
          const sortedConversations = conversations.sort((a, b) => {
            return new Date(b.updated_at || b.created_at) - new Date(a.updated_at || a.created_at);
          });

          // Show ALL conversations instead of limiting to 10
          sortedConversations.forEach(conversation => {
            const historyItem = this.createHistoryItem(conversation);
            historyContainer.appendChild(historyItem);
          });

          // Add collapse button at the bottom
          if (conversations.length > 10) {
            const collapseButton = document.createElement('div');
            collapseButton.className = 'text-center py-2 px-3 border-t border-gray-200 mt-2';
            collapseButton.innerHTML = `
              <button class="text-xs text-gray-600 hover:text-gray-800 transition-colors" onclick="window.arzaniChat.showLimitedHistory()">
                Show Recent Only
              </button>
            `;
            historyContainer.appendChild(collapseButton);
          }
        };
          // Load chat history with the modified display method
        window.arzaniClient.loadChatHistory().then(() => {
          // Restore original display method after showing all
          window.arzaniClient.displayChatHistory = originalDisplayMethod;
        });
      } else {
        console.warn('Show all history not available - neither sidebar nor client initialized');
      }
    },      showLimitedHistory: function() {
      console.log('Showing limited chat history via sidebar...');
      // Use sidebar refresh for consistency
      if (window.arzaniModernSidebar && typeof window.arzaniModernSidebar.refresh === 'function') {
        window.arzaniModernSidebar.refresh(); // This is debounced
      } else if (window.arzaniClient && typeof window.arzaniClient.loadChatHistory === 'function') {
        // Fallback when sidebar is not available
        console.log('Sidebar not available, using direct refresh...');
        window.arzaniClient.loadChatHistory();
      } else {
        console.warn('Show limited history not available - neither sidebar nor client initialized');
      }
    },
    
    loadConversationFromSearch: function(conversationId) {
      if (window.arzaniClient && typeof window.arzaniClient.loadConversationFromSearch === 'function') {
        console.log('Loading conversation from search:', conversationId);
        window.arzaniClient.loadConversationFromSearch(conversationId);
      } else {
        console.warn('Load conversation from search not available - client not initialized');
      }
    }
  };
  
  // Add copy button to the welcome message
  setTimeout(() => {
    const welcomeMessage = document.querySelector('.message-bubble');
    if (welcomeMessage && window.arzaniClient) {
      const welcomeText = "Hello! I'm Arzani, your AI business marketplace assistant. I can help you with business valuations, finding listings, legal advice, and financial guidance. What would you like to know?";
      window.arzaniClient.addCopyButton(welcomeMessage, welcomeText);
    }
  }, 500);
  
  // Add disclaimer test functionality for debugging
  window.testDisclaimer = () => {
    if (window.arzaniClient) {
      window.arzaniClient.testShowDisclaimer();
    }
  };
  console.log('Arzani X A2A Client initialized');
  console.log('A2A Agent URLs:', window.arzaniClient.agentUrls);
  console.log('Selected Agent:', window.arzaniClient.selectedAgent);
  console.log('To test disclaimer popup, press Ctrl+Shift+D or run testDisclaimer() in console');  // Initialize Modern Sidebar
  window.arzaniModernSidebar = new ArzaniModernSidebar();
  window.arzaniModernSidebar.setArzaniClient(window.arzaniClient);
  console.log('Modern sidebar initialized and linked to client');
  
  // Initialize complete mainChatInput synchronization  
  console.log('Starting complete mainChatInput synchronization initialization...');
  // Wait for all components to be ready
  let initializationComplete = false;
  let initializationAttempts = 0;
  const maxInitializationAttempts = 20; // Max 10 seconds of attempts
  
  const initializeComponents = () => {
    if (initializationComplete) {
      console.log('Components already initialized, skipping...');
      return;
    }
    
    initializationAttempts++;
    
    if (initializationAttempts > maxInitializationAttempts) {
      console.warn('Max initialization attempts reached. Some components may not be ready.');
      return;
    }
    
    if (window.arzaniClient && window.arzaniModernSidebar && window.arzaniPersistenceManager) {
      console.log('All components ready - initializing synchronization...');
      initializationComplete = true;
      
      try {
        // Ensure persistence manager is properly connected to client
        if (window.arzaniClient.persistenceManager !== window.arzaniPersistenceManager) {
          window.arzaniClient.persistenceManager = window.arzaniPersistenceManager;
          console.log('Persistence manager connected to A2A client');
        }
        
        // Ensure sidebar is connected to persistence manager
        if (window.arzaniModernSidebar.persistenceManager !== window.arzaniPersistenceManager) {
          window.arzaniModernSidebar.persistenceManager = window.arzaniPersistenceManager;
          console.log('Persistence manager connected to modern sidebar');
        }
          // Setup bidirectional communication between sidebar and client
        if (typeof window.arzaniModernSidebar.setArzaniClient === 'function' && window.arzaniClient) {
          console.log('Connecting sidebar to A2A client');
          window.arzaniModernSidebar.setArzaniClient(window.arzaniClient);
          
          // Ensure the client has the necessary methods
          if (typeof window.arzaniClient.clearCurrentConversation !== 'function') {
            console.log('Adding missing clearCurrentConversation method');
            window.arzaniClient.clearCurrentConversation = function() {
              console.log('Clearing current conversation (fallback)');
              try {
                if (window.ArzaniHelpers?.clearMessagesContainer) {
                  window.ArzaniHelpers.clearMessagesContainer();
                } else {
                  const messagesContainer = document.getElementById('messagesContainer');
                  if (messagesContainer) {
                    messagesContainer.innerHTML = '';
                  }
                }
              } catch (error) {
                console.error('Error in clearCurrentConversation fallback:', error);
              }
            };
          }
        }
        
        // Setup real-time updates if not already done
        if (window.arzaniPersistenceManager && typeof window.arzaniPersistenceManager.setupRealTimeUpdates === 'function') {
          window.arzaniPersistenceManager.setupRealTimeUpdates();
          console.log('Real-time updates initialized');
        }
        
        // Sync any existing conversation state
        const currentConversationId = window.arzaniClient.getCurrentConversationId();
        if (currentConversationId && window.arzaniPersistenceManager) {
          window.arzaniPersistenceManager.syncWithMainChat(currentConversationId)
            .then(() => {
              console.log('Existing conversation synced with sidebar');
            })
            .catch(error => {
              console.warn('Failed to sync existing conversation:', error);
            });
        }
        
        // Setup message event listeners for real-time synchronization
        const setupMessageListeners = () => {
          // Listen for new messages in main chat
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach((node) => {
                  if (node.nodeType === Node.ELEMENT_NODE && 
                      (node.classList.contains('message-bubble') || 
                       node.querySelector('.message-bubble'))) {
                    // New message detected, trigger sidebar update
                    if (window.arzaniPersistenceManager && 
                        typeof window.arzaniPersistenceManager.onNewMessage === 'function') {
                      const messageElement = node.classList.contains('message-bubble') ? 
                        node : node.querySelector('.message-bubble');
                      const messageText = messageElement.textContent.trim();
                      const isUser = messageElement.classList.contains('user-message') || 
                                   messageElement.parentElement.classList.contains('user-message');
                      
                      window.arzaniPersistenceManager.onNewMessage({
                        content: messageText,
                        isUser: isUser,
                        timestamp: new Date().toISOString(),
                        conversationId: window.arzaniClient.getCurrentConversationId()
                      });
                    }
                  }
                });
              }
            });
          });
          
          // Observe the main chat container for new messages
          const chatContainer = document.querySelector('.chat-container') || 
                               document.querySelector('#chat-messages') ||
                               document.querySelector('.messages-container');
          
          if (chatContainer) {
            observer.observe(chatContainer, {
              childList: true,
              subtree: true
            });
            console.log('Message observer setup complete');
          } else {
            console.warn('Chat container not found for message observation');
          }
        };
        
        // Setup message listeners
        setupMessageListeners();
        
        // Validate integration
        const validateIntegration = () => {
          const validations = [
            {
              name: 'A2A Client',
              check: () => window.arzaniClient && typeof window.arzaniClient.sendToA2A === 'function'
            },
            {
              name: 'Modern Sidebar',
              check: () => window.arzaniModernSidebar && typeof window.arzaniModernSidebar.updateConversationsList === 'function'
            },
            {
              name: 'Persistence Manager',
              check: () => window.arzaniPersistenceManager && typeof window.arzaniPersistenceManager.saveMessage === 'function'
            },
            {
              name: 'Client-Persistence Connection',
              check: () => window.arzaniClient.persistenceManager === window.arzaniPersistenceManager
            },
            {
              name: 'Sidebar-Persistence Connection',
              check: () => window.arzaniModernSidebar.persistenceManager === window.arzaniPersistenceManager
            }
          ];
          
          const results = validations.map(validation => ({
            ...validation,
            passed: validation.check()
          }));
          
          const allPassed = results.every(result => result.passed);
          
          console.log('Integration Validation Results:');
          results.forEach(result => {
            console.log(`  ${result.name}: ${result.passed ? '‚úì' : '‚úó'}`);
          });
          
          if (allPassed) {
            console.log('üéâ MainChatInput synchronization complete! All components integrated successfully.');
          } else {
            console.warn('‚ö†Ô∏è Some integration validations failed. Check the results above.');
          }
          
          return allPassed;
        };
        
        // Run validation
        const isValid = validateIntegration();
        
        // Add global methods for debugging and testing
        window.arzaniDebug = {
          validateIntegration,
          forceSync: () => {
            const conversationId = window.arzaniClient.getCurrentConversationId();
            if (conversationId && window.arzaniPersistenceManager) {
              return window.arzaniPersistenceManager.syncWithMainChat(conversationId);
            }
            return Promise.reject('No active conversation or persistence manager');
          },
          refreshSidebar: () => {
            if (window.arzaniModernSidebar && typeof window.arzaniModernSidebar.updateConversationsList === 'function') {
              window.arzaniModernSidebar.updateConversationsList();
            }
          },
          testPersistence: () => {
            if (window.arzaniPersistenceManager) {
              return window.arzaniPersistenceManager.testConnection();
            }
            return Promise.reject('Persistence manager not available');
          }
        };
          console.log('Debug methods available at window.arzaniDebug');
        
      } catch (error) {
        console.error('Error during synchronization initialization:', error);
      }    } else {
      if (initializationAttempts <= maxInitializationAttempts) {
        console.log(`Waiting for components to initialize... (attempt ${initializationAttempts}/${maxInitializationAttempts})`);
        console.log('Missing components:', {
          arzaniClient: !window.arzaniClient,
          arzaniModernSidebar: !window.arzaniModernSidebar,
          arzaniPersistenceManager: !window.arzaniPersistenceManager
        });
        setTimeout(initializeComponents, 500);
      } else {
        console.warn('Components failed to initialize after maximum attempts');
      }
    }
  };  
  // Start initialization with a small delay to ensure DOM is ready
  setTimeout(initializeComponents, 100);
});

// Error handling for A2A connection
window.addEventListener('error', (event) => {
  console.error('JavaScript error:', event.error);
});

// Global helper functions for search functionality
window.loadConversationFromSearch = function(conversationId) {
  if (window.arzaniClient && typeof window.arzaniClient.loadConversationFromSearch === 'function') {
    return window.arzaniClient.loadConversationFromSearch(conversationId);
  } else {
    console.error('Arzani client not available for search loading');
  }
};

// Ensure search functionality is available globally
window.performSearch = function(query) {
  if (window.arzaniClient && typeof window.arzaniClient.performConversationSearch === 'function') {
    return window.arzaniClient.performConversationSearch(query);  } else {
    console.error('Arzani client not available for search');
  }
};

// Debug function to test search
window.testSearch = function(query = 'test') {
  console.log('Testing search with query:', query);
  const searchInput = document.getElementById('conversationSearch');
  if (searchInput) {
    searchInput.value = query;
    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
  } else {
    console.error('Search input not found');
  }
};

// Global resend message function
window.resendMessage = function(messageId) {
  const messageElement = document.getElementById(messageId);
  if (!messageElement) {
    console.error('Message not found:', messageId);
    alert('Message not found. Please try again.');
    return;
  }
  
  const originalContent = messageElement.getAttribute('data-original-content');
  if (!originalContent) {
    console.error('Original content not found for message:', messageId);
    alert('Cannot resend message: original content not found.');
    return;
  }
  
  const clientMessageId = messageElement.getAttribute('data-client-message-id') || messageElement.getAttribute('data-message-id');
  if (!clientMessageId) {
    console.error('Client message ID not found for message:', messageId);
    alert('Cannot resend message: message ID not found.');
    return;
  }
  
  // Get the current session ID from persistence
  const sessionId = window.arzaniPersistence?.getCurrentSessionId?.() || null;
  
  if (!sessionId) {
    alert('Cannot resend message: no active session found.');
    return;
  }
  
  console.log(`üîÑ Resending message with ID: ${clientMessageId}`);
  
  // Show confirmation
  if (!confirm('Are you sure you want to resend this message? This will generate a new AI response.')) {
    return;
  }
  
  try {
    // Use the persistence layer to resend the message with the same ID
    if (window.arzaniPersistence && typeof window.arzaniPersistence.resendMessage === 'function') {
      window.arzaniPersistence.resendMessage(sessionId, clientMessageId, originalContent, 'user')
        .then(() => {
          console.log('‚úÖ Message resent successfully');
          // Optionally trigger AI response here if needed
          if (window.arzaniClient && typeof window.arzaniClient.sendToA2A === 'function') {
            window.arzaniClient.sendToA2A(originalContent, clientMessageId);
          }
        })
        .catch(error => {
          console.error('‚ùå Failed to resend message:', error);
          alert(`Failed to resend message: ${error.message}`);
        });
    } else {
      throw new Error('Persistence layer not available');
    }
  } catch (error) {
    console.error('‚ùå Failed to resend message:', error);
    alert(`Failed to resend message: ${error.message}`);
  }
};

// Global function to ensure conversation access is always available
window.ensureConversationAccess = function(conversationId) {
  console.log('üéØ Ensuring conversation access for:', conversationId);
  
  // If main client exists, use it
  if (window.arzaniClient) {
    window.arzaniClient.forceTransitionToConversationLayout();
    window.arzaniClient.setCurrentConversation(conversationId);
    return window.arzaniClient.loadConversationById(conversationId);
  }
  
  // Fallback: force layout change without client
  const mainHeading = document.getElementById('mainHeading');
  const mainFormContainer = document.getElementById('mainFormContainer');
  const conversationArea = document.getElementById('conversationArea');
  const bottomInputArea = document.getElementById('bottomInputArea');
  const contentBody = document.querySelector('.content-body');
  
  if (mainHeading) mainHeading.style.display = 'none';
  if (mainFormContainer) mainFormContainer.style.display = 'none';
  if (conversationArea) conversationArea.classList.remove('hidden');
  if (bottomInputArea) bottomInputArea.classList.remove('hidden');
  if (contentBody) contentBody.classList.add('conversation-mode');
    console.log('‚úÖ Conversation access ensured via fallback method');
  return Promise.resolve();
};

// Test function for ThinkingPanel
window.testThinkingPanel = function(agentType = 'orchestrator') {
  console.log(`üß™ Testing ThinkingPanel for ${agentType}...`);
  
  // Ensure we're in conversation mode first
  if (window.arzaniClient && !window.arzaniClient.conversationStarted) {
    window.arzaniClient.transitionToConversationLayout();
  }
  
  // Create a test thinking panel
  const testPanel = new ThinkingPanel(agentType, 'test-thinking-' + Date.now());
  
  // Add some test thoughts with delays
  setTimeout(() => {
    testPanel.addThought("Analyzing your test request...", false);
  }, 500);
  
  setTimeout(() => {
    testPanel.addThought("Processing with advanced AI...", false);
  }, 1500);
  
  setTimeout(() => {
    testPanel.addThought("Generating comprehensive response...", false);
  }, 2500);
  
  setTimeout(() => {
    testPanel.addThought("Test completed successfully! ‚úÖ", true);
    testPanel.completeAll();
  }, 3500);
  
  // Auto-remove after 10 seconds
  setTimeout(() => {
    testPanel.remove();
    console.log('üßπ Test ThinkingPanel removed');
  }, 8000);
  
  console.log('‚úÖ ThinkingPanel test started! Check the message area.');
  return testPanel;
};

console.log('üîß ThinkingPanel test function available: window.testThinkingPanel()');
</script>

</body>
</html>