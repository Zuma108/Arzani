name: Deploy to Google Cloud Run (Simplified)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  PROJECT_ID: cool-mile-437217-s2
  REGION: europe-west2
  SERVICE_NAME: arzani-marketplace
  NODE_VERSION: '20.x'
  
  # Database configuration
  DB_INSTANCE: arzani-marketplace-db-v17
  DB_NAME: arzani_marketplace
  DB_USER: marketplace_user
  
  # Image configuration
  IMAGE_NAME: arzani-marketplace
  REGISTRY: europe-west2-docker.pkg.dev

permissions:
  contents: read
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    # Install system dependencies
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libcairo2-dev libpango1.0-dev libjpeg-dev libgif-dev librsvg2-dev

    # Authenticate to Google Cloud
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

    # Setup Google Cloud CLI
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}

    # Configure Docker
    - name: Configure Docker
      run: gcloud auth configure-docker ${{ env.REGISTRY }}

    # Install dependencies
    - name: Install dependencies
      run: npm ci --production=false

    # Verify required secrets
    - name: Check required secrets
      run: |
        missing=""
        [ -z "${{ secrets.DB_PASSWORD }}" ] && missing="$missing DB_PASSWORD"
        [ -z "${{ secrets.JWT_SECRET }}" ] && missing="$missing JWT_SECRET"
        [ -z "${{ secrets.STRIPE_SECRET_KEY }}" ] && missing="$missing STRIPE_SECRET_KEY"
        [ -z "${{ secrets.OPENAI_API_KEY }}" ] && missing="$missing OPENAI_API_KEY"
        
        if [ -n "$missing" ]; then
          echo "‚ùå Missing required secrets:$missing"
          echo "Add these in GitHub repository settings > Secrets and variables > Actions"
          exit 1
        fi
        echo "‚úÖ All required secrets are present"

    # Simple production build
    - name: Create production build
      run: |
        echo "üì¶ Creating production build..."
        
        # Show directory overview (limited output)
        echo "üìÇ Root directory file count: $(find . -maxdepth 1 -type f | wc -l)"
        echo "üìÅ Root directory size: $(du -sh . | cut -f1)"
        
        # Verify essential files exist
        [ -f "package.json" ] || { echo "‚ùå package.json missing"; exit 1; }
        [ -f "server.js" ] || { echo "‚ùå server.js missing"; exit 1; }
        echo "‚úÖ Essential files verified"
        
        # Create production directory
        mkdir production
        
        # Copy essential files
        cp package.json server.js production/
        [ -f "package-lock.json" ] && cp package-lock.json production/
        
        # Copy critical directories with explicit verification
        CRITICAL_DIRS="api views public routes middleware services libs utils migrations socket"
        for dir in $CRITICAL_DIRS; do
          if [ -d "$dir" ]; then
            echo "üìÅ Copying $dir directory..."
            cp -r "$dir" production/
            # Verify the copy worked
            if [ -d "production/$dir" ]; then
              file_count=$(find "production/$dir" -type f | wc -l)
              echo "‚úÖ $dir copied successfully ($file_count files)"
            else
              echo "‚ùå Failed to copy $dir directory"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è $dir directory not found, skipping"
          fi
        done
        
        # Explicitly verify api directory and key files
        if [ -d "production/api" ]; then
          echo "üîç Verifying api directory contents:"
          ls -la production/api/
          if [ -f "production/api/valuation.js" ]; then
            echo "‚úÖ valuation.js found in production build"
          else
            echo "‚ùå valuation.js missing in production build"
            exit 1
          fi
          if [ -f "production/api/public-valuation.js" ]; then
            echo "‚úÖ public-valuation.js found in production build"
          else
            echo "‚ùå public-valuation.js missing in production build"
            exit 1
          fi
        else
          echo "‚ùå api directory missing in production build"
          exit 1
        fi
        
        # Always ensure scripts directory exists
        if [ -d "scripts" ]; then
          cp -r scripts production/
          echo "‚úÖ Scripts directory copied"
        else
          mkdir -p production/scripts
          echo "console.log('‚úÖ AI assets ready - minimal version');" > production/scripts/ensure-ai-assets.js
          echo "‚úÖ Created minimal scripts directory"
        fi
        
        # Copy other important files
        for file in db.js config.js app.js database.js root-route-fix.js; do
          [ -f "$file" ] && cp "$file" production/ || echo "‚ö†Ô∏è $file not found, skipping"
        done
        
        echo "‚úÖ Production build created"
        echo "üìä Production files: $(find production/ -type f | wc -l) files"

    # Fix package.json and install production dependencies
    - name: Fix package.json and install production dependencies
      run: |
        cd production
        
        # Create a clean package.json without postinstall script
        node -e "
          const pkg = JSON.parse(require('fs').readFileSync('package.json', 'utf8'));
          if (pkg.scripts && pkg.scripts.postinstall) {
            delete pkg.scripts.postinstall;
            console.log('‚úÖ Removed postinstall script');
          }
          require('fs').writeFileSync('package.json', JSON.stringify(pkg, null, 2));
        "
        
        # Install dependencies
        npm ci --only=production --silent
        echo "‚úÖ Production dependencies installed"

    # Create optimized Dockerfile AFTER production directory is built
    - name: Create Dockerfile
      run: |
        cat > Dockerfile << 'EOF'
        FROM node:20-alpine
        
        # Install system dependencies for canvas and other native modules
        RUN apk add --no-cache \
            cairo-dev \
            pango-dev \
            jpeg-dev \
            giflib-dev \
            librsvg-dev \
            build-base \
            python3 \
            make \
            g++ \
            curl \
            dumb-init
        
        # Set working directory
        WORKDIR /app
        
        # Copy production files
        COPY production/ ./
        
        # Create scripts directory if it doesn't exist (for safety)
        RUN mkdir -p scripts
        
        # Create non-root user
        RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
        RUN chown -R nodejs:nodejs /app
        USER nodejs
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
          CMD curl -f http://localhost:8080/health || exit 1
        
        # Environment
        ENV NODE_ENV=production
        
        # Start application
        EXPOSE 8080
        ENTRYPOINT ["dumb-init", "--"]
        CMD ["node", "server.js"]
        EOF

    # Build and push Docker image
    - name: Build and push image
      run: |
        IMAGE_URI="${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        LATEST_URI="${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.IMAGE_NAME }}:latest"
        
        echo "üê≥ Building image: $IMAGE_URI"
        docker build --platform linux/amd64 -t $IMAGE_URI .
        
        echo "üì§ Pushing image..."
        docker push $IMAGE_URI
        docker tag $IMAGE_URI $LATEST_URI
        docker push $LATEST_URI
        
        echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

    # Setup Cloud SQL (create if doesn't exist)
    - name: Setup Cloud SQL
      run: |
        if ! gcloud sql instances describe ${{ env.DB_INSTANCE }} --quiet 2>/dev/null; then
          echo "üìä Creating Cloud SQL instance..."
          gcloud sql instances create ${{ env.DB_INSTANCE }} \
            --database-version=POSTGRES_17 \
            --tier=db-custom-1-3840 \
            --region=${{ env.REGION }} \
            --storage-type=SSD \
            --storage-size=10GB
          
          gcloud sql databases create ${{ env.DB_NAME }} --instance=${{ env.DB_INSTANCE }}
          gcloud sql users create ${{ env.DB_USER }} --instance=${{ env.DB_INSTANCE }} --password=${{ secrets.DB_PASSWORD }}
        fi
        
        CONNECTION_NAME=$(gcloud sql instances describe ${{ env.DB_INSTANCE }} --format="value(connectionName)")
        echo "DB_CONNECTION_NAME=$CONNECTION_NAME" >> $GITHUB_ENV

    # Deploy to Cloud Run
    - name: Deploy to Cloud Run
      run: |
        gcloud run deploy ${{ env.SERVICE_NAME }} \
          --image=${{ env.IMAGE_URI }} \
          --region=${{ env.REGION }} \
          --platform=managed \
          --allow-unauthenticated \
          --port=8080 \
          --memory=1Gi \
          --cpu=1 \
          --min-instances=0 \
          --max-instances=10 \
          --timeout=300 \
          --add-cloudsql-instances=${{ env.DB_CONNECTION_NAME }} \
          --set-env-vars="NODE_ENV=production,DATABASE_URL=postgresql://${{ env.DB_USER }}:${{ secrets.DB_PASSWORD }}@localhost:5432/${{ env.DB_NAME }}?host=/cloudsql/${{ env.DB_CONNECTION_NAME }},JWT_SECRET=${{ secrets.JWT_SECRET }},STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }},OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }},A2A_AUTH_ENABLED=false,DATABASE_SSL=false"

    # Get and test deployment
    - name: Verify deployment
      run: |
        SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.REGION }} --format="value(status.url)")
        echo "üöÄ Deployed to: $SERVICE_URL"
        
        # Wait and test
        sleep 30
        if curl -f "$SERVICE_URL/health"; then
          echo "‚úÖ Deployment successful!"
          echo "üåê Application: $SERVICE_URL"
        else
          echo "‚ö†Ô∏è Health check failed, but deployment completed"
          echo "Check logs: gcloud run services logs read ${{ env.SERVICE_NAME }} --region=${{ env.REGION }}"
        fi
