name: Deploy to Amazon EC2 - London

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: eu-west-2                     # London region
  EC2_HOST: 13.42.54.24                     # Your EC2 instance public IP
  EC2_INSTANCE_ID: i-019286270466a5ea6      # Your EC2 instance ID
  NODE_VERSION: '18.x'                      # matches your engine requirements in package.json

permissions:
  contents: read
  id-token: write  # Required for requesting the JWT

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    # Install canvas dependencies before any npm operations
    - name: Install dependencies for canvas
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libcairo2-dev libpango1.0-dev libjpeg-dev libgif-dev librsvg2-dev

    # Install global dependencies first
    - name: Install node-pre-gyp globally
      run: sudo npm install -g node-pre-gyp
      
    # Regular npm install with explicit handling for canvas
    - name: npm install
      run: |
        npm install --no-bin-links
        # Make sure node-pre-gyp can be found
        chmod +x node_modules/.bin/node-pre-gyp
        
        # Explicitly run node-pre-gyp for canvas 
        cd node_modules/canvas
        ../node-pre-gyp/bin/node-pre-gyp install --fallback-to-build --update-binary || echo "Canvas rebuild failed but continuing"
        cd ../..
      env:
        CANVAS_PREBUILT_VERSION: 2.11.2

    # Fix permissions for all binaries in node_modules/.bin
    - name: Fix permissions for node binaries
      run: |
        find node_modules/.bin -type f -exec chmod +x {} \;
        echo "Fixed permissions for binaries in node_modules/.bin"

    # Build step
    - name: Build
      run: npm run build --if-present
      env:
        NODE_ENV: test
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}

    # Separate test step with explicit path to Jest binary
    - name: Run tests
      run: |
        # Ensure Jest binary is executable
        chmod +x node_modules/.bin/jest
        node_modules/.bin/jest --passWithNoTests
      env:
        NODE_ENV: test
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        
    # Create deployment package
    - name: Create deployment package
      run: |
        # Create a directory for production files
        mkdir -p dist
        
        # Copy necessary files for deployment (excluding development files)
        rsync -av --exclude='.git' --exclude='.github' --exclude='node_modules' --exclude='tests' \
          --exclude='*.md' --exclude='*.env' --exclude='*.log' . dist/
        
        # Create package.json without dev dependencies for production
        jq 'del(.devDependencies)' package.json > dist/package.json
        
        # Create deployment archive
        cd dist && zip -r ../deployment.zip .
        cd ..
        echo "Created deployment package: deployment.zip"

    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: deployment.zip

  deploy:
    name: Deploy
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: 'Production'
      url: ${{ format('http://{0}:3000', env.EC2_HOST) }}

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app
        
    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Verify AWS CLI setup
    - name: Verify AWS CLI
      run: |
        aws --version
        aws sts get-caller-identity
        echo "Successfully authenticated with AWS"
        
    # Check EC2 instance status
    - name: Check EC2 instance status
      run: |
        echo "Checking EC2 instance status..."
        aws ec2 describe-instance-status --instance-id ${{ env.EC2_INSTANCE_ID }} --output json
        
        # Get instance state
        INSTANCE_STATE=$(aws ec2 describe-instances --instance-id ${{ env.EC2_INSTANCE_ID }} \
          --query "Reservations[0].Instances[0].State.Name" --output text)
          
        if [ "$INSTANCE_STATE" != "running" ]; then
          echo "Instance is not running. Current state: $INSTANCE_STATE"
          echo "Starting the instance..."
          aws ec2 start-instances --instance-id ${{ env.EC2_INSTANCE_ID }}
          
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-id ${{ env.EC2_INSTANCE_ID }}
          
          echo "Instance is now running. Waiting 30 seconds for services to start..."
          sleep 30
        else
          echo "Instance is already running."
        fi

    # Setup SSH
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
        chmod 600 ~/.ssh/ec2_key.pem
        
        # Add the host to known_hosts to avoid prompt during connection
        ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts

    # Deploy to EC2
    - name: Deploy to EC2
      run: |
        echo "Deploying application to EC2 instance..."
        
        # Transfer deployment package to the server
        scp -i ~/.ssh/ec2_key.pem deployment.zip ec2-user@${{ env.EC2_HOST }}:~/deployment.zip
        
        # Connect to server and deploy
        ssh -i ~/.ssh/ec2_key.pem ec2-user@${{ env.EC2_HOST }} << 'EOF'
          echo "Connected to EC2 instance in London region"
          
          # Create directory for the app if it doesn't exist
          mkdir -p ~/app
          
          # Backup current deployment if it exists
          if [ -d ~/app/current ]; then
            timestamp=$(date +%Y%m%d%H%M%S)
            mkdir -p ~/app/backup
            mv ~/app/current ~/app/backup/backup_$timestamp
          fi
          
          # Create new deployment directory
          mkdir -p ~/app/current
          
          # Extract deployment package
          unzip -o ~/deployment.zip -d ~/app/current
          
          # Install production dependencies
          cd ~/app/current
          npm install --production
          
          # Install PM2 if not already installed
          if ! command -v pm2 &> /dev/null; then
            echo "Installing PM2..."
            npm install -g pm2
          fi
          
          # Create .env file with required environment variables
          echo "Creating environment variables file..."
          cat > ~/app/current/.env << 'ENVFILE'
OPENAI_API_KEY='${{ secrets.OPENAI_API_KEY }}'
NODE_ENV=production
PORT=3000
ENVFILE
          
          # Stop existing PM2 process if running
          pm2 stop marketplace 2>/dev/null || true
          
          # Start application with PM2 and environment variables
          echo "Starting application..."
          cd ~/app/current
          pm2 start ecosystem.config.js --env production
          
          # Save PM2 process list to resurrect after reboot
          pm2 save
          
          # Setup PM2 to start on system startup if not already set
          pm2 startup | grep -v "sudo" | sh
          
          # Clean up deployment package
          rm ~/deployment.zip
          
          echo "Deployment completed successfully!"
        EOF

    # Verify deployment
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        sleep 5
        
        # Use curl to check if the application is responding
        response_code=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.EC2_HOST }}:3000 || echo "failed")
        
        if [[ $response_code == "200" ]]; then
          echo "✅ Application successfully deployed and responding with status code 200"
          echo "Application URL: http://${{ env.EC2_HOST }}:3000"
        else
          echo "⚠️ Application check returned status code: $response_code"
          echo "It may take a few moments for the application to fully start"
          echo "Application URL: http://${{ env.EC2_HOST }}:3000"
          
          # Don't fail the workflow, as the app might just need more time to start
          echo "Deployment completed, but application verification needs manual check"
        fi