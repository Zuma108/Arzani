name: AWS Deployment

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  NODE_VERSION: '18.x'
  AWS_REGION: 'us-east-1'  # Change to your preferred AWS region
  EB_APP_NAME: 'my-marketplace'  # Name for your Elastic Beanstalk application
  EB_ENV_NAME: 'MyMarketplace-env'  # Name for your Elastic Beanstalk environment
  S3_BUCKET: 'my-marketplace-deployments'  # S3 bucket for deployment artifacts

permissions:
  contents: read
  id-token: write  # Required for requesting the JWT

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    # Install global dependencies first
    - name: Install node-pre-gyp globally
      run: sudo npm install -g node-pre-gyp
      
    # Regular npm install with --no-bin-links to avoid symlink issues
    - name: npm install
      run: npm install --no-bin-links

    # Fix permissions for all binaries in node_modules/.bin
    - name: Fix permissions for node binaries
      run: |
        find node_modules/.bin -type f -exec chmod +x {} \;
        echo "Fixed permissions for binaries in node_modules/.bin"

    # Rebuild canvas using sudo
    - name: Rebuild canvas module
      run: sudo npm rebuild canvas --update-binary

    # Build step
    - name: Build
      run: npm run build --if-present
      env:
        NODE_ENV: test
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}

    # Separate test step with explicit path to Jest binary
    - name: Run tests
      run: |
        # Ensure Jest binary is executable
        chmod +x node_modules/.bin/jest
        node_modules/.bin/jest --passWithNoTests
      env:
        NODE_ENV: test
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        
    # Create ZIP deployment package for AWS
    - name: Generate deployment package
      run: |
        zip -r deploy.zip . -x "node_modules/*" "tests/*" ".git/*" ".github/*" "*.md" "*.env"
        echo "Created deployment package: deploy.zip"

    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: deploy.zip

  deploy:
    permissions:
      contents: read
      id-token: write  # Required for requesting the JWT
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Production'
      url: ${{ steps.deploy.outputs.webapp-url }}

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app
        
    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Verify AWS CLI setup
    - name: Verify AWS CLI
      run: |
        aws --version
        aws sts get-caller-identity
        echo "Successfully authenticated with AWS"
        
    # Check if Elastic Beanstalk application exists
    - name: Check Elastic Beanstalk application
      id: check-eb-app
      run: |
        if aws elasticbeanstalk describe-applications --application-names ${{ env.EB_APP_NAME }} &>/dev/null; then
          echo "Application ${{ env.EB_APP_NAME }} exists"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "Application ${{ env.EB_APP_NAME }} does not exist"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi
        
    # Create Elastic Beanstalk application if it doesn't exist
    - name: Create Elastic Beanstalk application
      if: steps.check-eb-app.outputs.exists == 'false'
      run: |
        aws elasticbeanstalk create-application \
          --application-name ${{ env.EB_APP_NAME }} \
          --description "My Marketplace Application"
        echo "Created Elastic Beanstalk application: ${{ env.EB_APP_NAME }}"
          
    # Check if S3 bucket exists
    - name: Check S3 bucket
      id: check-s3-bucket
      run: |
        if aws s3api head-bucket --bucket ${{ env.S3_BUCKET }} 2>/dev/null; then
          echo "S3 bucket ${{ env.S3_BUCKET }} exists"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "S3 bucket ${{ env.S3_BUCKET }} does not exist"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi
        
    # Create S3 bucket if it doesn't exist
    - name: Create S3 bucket
      if: steps.check-s3-bucket.outputs.exists == 'false'
      run: |
        aws s3api create-bucket \
          --bucket ${{ env.S3_BUCKET }} \
          --region ${{ env.AWS_REGION }} \
          $( [[ "${{ env.AWS_REGION }}" != "us-east-1" ]] && echo "--create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}" )
        echo "Created S3 bucket: ${{ env.S3_BUCKET }}"
        
    # Upload deployment package to S3
    - name: Upload deployment package to S3
      run: |
        aws s3 cp deploy.zip s3://${{ env.S3_BUCKET }}/deploy-${{ github.sha }}.zip
        echo "Uploaded deployment package to S3"
        
    # Check if Elastic Beanstalk environment exists
    - name: Check Elastic Beanstalk environment
      id: check-eb-env
      run: |
        if aws elasticbeanstalk describe-environments --environment-names ${{ env.EB_ENV_NAME }} --application-name ${{ env.EB_APP_NAME }} | grep -q "\"Status\": \"Ready\|Launching\|Updating\""; then
          echo "Environment ${{ env.EB_ENV_NAME }} exists"
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "Environment ${{ env.EB_ENV_NAME }} does not exist or is in an invalid state"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi
        
    # Create Elastic Beanstalk environment if it doesn't exist
    - name: Create Elastic Beanstalk environment
      if: steps.check-eb-env.outputs.exists == 'false'
      run: |
        # Check if platform exists
        PLATFORM=$(aws elasticbeanstalk list-available-solution-stacks | grep -m1 "64bit Amazon Linux 2.*running Node.js" | sed 's/^.*"\(.*\)".*$/\1/')
        
        if [ -n "$PLATFORM" ]; then
          echo "Using platform: $PLATFORM"
          
          aws elasticbeanstalk create-environment \
            --application-name ${{ env.EB_APP_NAME }} \
            --environment-name ${{ env.EB_ENV_NAME }} \
            --solution-stack-name "$PLATFORM" \
            --option-settings file://eb-options.json || echo "Failed to create environment with options file"
            
          # If the above command fails, try without options file
          if [ $? -ne 0 ]; then
            aws elasticbeanstalk create-environment \
              --application-name ${{ env.EB_APP_NAME }} \
              --environment-name ${{ env.EB_ENV_NAME }} \
              --solution-stack-name "$PLATFORM"
          fi
          
          echo "Created Elastic Beanstalk environment: ${{ env.EB_ENV_NAME }}"
          echo "Waiting for environment to be ready..."
          aws elasticbeanstalk wait environment-exists \
            --application-name ${{ env.EB_APP_NAME }} \
            --environment-name ${{ env.EB_ENV_NAME }}
        else
          echo "No suitable Node.js platform found!"
          exit 1
        fi
        
    # Deploy to Elastic Beanstalk
    - name: Deploy to Elastic Beanstalk
      id: deploy
      run: |
        # Create a new application version
        aws elasticbeanstalk create-application-version \
          --application-name ${{ env.EB_APP_NAME }} \
          --version-label "ver-${{ github.sha }}" \
          --source-bundle S3Bucket="${{ env.S3_BUCKET }}",S3Key="deploy-${{ github.sha }}.zip" \
          --description "Deployment from GitHub Actions"
          
        # Update the environment to use the new version
        aws elasticbeanstalk update-environment \
          --application-name ${{ env.EB_APP_NAME }} \
          --environment-name ${{ env.EB_ENV_NAME }} \
          --version-label "ver-${{ github.sha }}"
          
        # Wait for deployment to complete
        echo "Waiting for environment update to complete..."
        aws elasticbeanstalk wait environment-updated \
          --application-name ${{ env.EB_APP_NAME }} \
          --environment-name ${{ env.EB_ENV_NAME }}
          
        # Get environment URL
        ENV_URL=$(aws elasticbeanstalk describe-environments \
          --environment-names ${{ env.EB_ENV_NAME }} \
          --application-name ${{ env.EB_APP_NAME }} \
          --query "Environments[0].CNAME" \
          --output text)
          
        echo "Application deployed successfully to $ENV_URL"
        echo "webapp-url=http://$ENV_URL" >> $GITHUB_OUTPUT
        
    # Verify deployment status
    - name: Verify deployment
      run: |
        ENV_HEALTH=$(aws elasticbeanstalk describe-environments \
          --environment-names ${{ env.EB_ENV_NAME }} \
          --application-name ${{ env.EB_APP_NAME }} \
          --query "Environments[0].Health" \
          --output text)
          
        ENV_STATUS=$(aws elasticbeanstalk describe-environments \
          --environment-names ${{ env.EB_ENV_NAME }} \
          --application-name ${{ env.EB_APP_NAME }} \
          --query "Environments[0].Status" \
          --output text)
          
        echo "Deployment status: $ENV_STATUS"
        echo "Environment health: $ENV_HEALTH"
        
        if [ "$ENV_HEALTH" != "Green" ]; then
          echo "Warning: Environment health is not optimal. Check AWS Console for details."
        fi