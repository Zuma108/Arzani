name: Deploy to Amazon EC2 - London

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: eu-west-2                     # London region
  EC2_HOST: 18.168.205.177                    # Updated EC2 instance public IP
  EC2_INSTANCE_ID: i-09eac96a568a22f1c      # Updated EC2 instance ID
  NODE_VERSION: '18.x'                      # matches your engine requirements in package.json
  RDS_DB_INSTANCE: marketplace-db           # RDS instance identifier
  RDS_DB_NAME: marketplace                  # Database name
  RDS_DB_USER: marketplace_user             # Database user
  RDS_DB_PASSWORD: Olumide123!              # Database password - MUST be moved to GitHub secrets
  RDS_BACKUP_RETENTION: 7                   # Days to keep automated backups

permissions:
  contents: read
  id-token: write  # Required for requesting the JWT

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    # Install canvas dependencies before any npm operations
    - name: Install system dependencies for canvas
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libcairo2-dev libpango1.0-dev libjpeg-dev libgif-dev librsvg2-dev

    # Install global dependencies first
    - name: Install node-pre-gyp globally
      run: sudo npm install -g node-pre-gyp
      
    # Use --unsafe-perm for npm install to avoid permission issues
    - name: npm install
      run: npm install --no-bin-links --unsafe-perm

    # Fix permissions for all binaries in node_modules/.bin
    - name: Fix permissions for node binaries
      run: |
        find node_modules/.bin -type f -exec chmod +x {} \;
        echo "Fixed permissions for binaries in node_modules/.bin"

    # Rebuild canvas with --unsafe-perm and fallback message
    - name: Rebuild canvas module
      run: npm rebuild canvas --update-binary --unsafe-perm || echo "Canvas rebuild failed but continuing"

    # Build step
    - name: Build
      run: npm run build --if-present
      env:
        NODE_ENV: test
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}

    # Separate test step with explicit path to Jest binary
    - name: Run tests
      run: |
        # Ensure Jest binary is executable
        chmod +x node_modules/.bin/jest
        node_modules/.bin/jest --passWithNoTests
      env:
        NODE_ENV: test
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        
    # Create deployment package
    - name: Create deployment package
      run: |
        # Create a directory for production files
        mkdir -p dist
        
        # Copy necessary files for deployment (excluding development files)
        rsync -av --exclude='.git' --exclude='.github' --exclude='node_modules' --exclude='tests' \
          --exclude='*.md' --exclude='*.env' --exclude='*.log' . dist/
        
        # Create package.json without dev dependencies for production
        jq 'del(.devDependencies)' package.json > dist/package.json
        
        # Create deployment archive
        cd dist && zip -r ../deployment.zip . 
        cd .. 
        echo "Created deployment package: deployment.zip"

    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: deployment.zip

  deploy:
    name: Deploy
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: 'Production'
      url: ${{ format('http://{0}:3000', env.EC2_HOST) }}

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app
        
    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Verify AWS CLI setup
    - name: Verify AWS CLI
      run: |
        aws --version
        aws sts get-caller-identity
        echo "Successfully authenticated with AWS"
        
    # Check EC2 instance status
    - name: Check EC2 instance status
      run: |
        echo "Checking EC2 instance status..."
        aws ec2 describe-instance-status --instance-id ${{ env.EC2_INSTANCE_ID }} --output json
        
        # Get instance state
        INSTANCE_STATE=$(aws ec2 describe-instances --instance-id ${{ env.EC2_INSTANCE_ID }} \
          --query "Reservations[0].Instances[0].State.Name" --output text)
          
        if [ "$INSTANCE_STATE" != "running" ]; then
          echo "Instance is not running. Current state: $INSTANCE_STATE"
          echo "Starting the instance..."
          aws ec2 start-instances --instance-id ${{ env.EC2_INSTANCE_ID }}
          
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-id ${{ env.EC2_INSTANCE_ID }}
          
          echo "Instance is now running. Waiting 30 seconds for services to start..."
          sleep 30
        else
          echo "Instance is already running."
        fi

    # Setup SSH
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
        chmod 600 ~/.ssh/ec2_key.pem
        
        # Add the host to known_hosts to avoid prompt during connection
        ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts

    # Check if RDS instance exists, create if it doesn't
    - name: Check RDS instance
      run: |
        echo "Checking if RDS instance exists..."
        
        # Check if the RDS instance already exists
        if aws rds describe-db-instances --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} > /dev/null 2>&1; then
          echo "RDS instance ${{ env.RDS_DB_INSTANCE }} already exists"
          
          # Get RDS endpoint
          RDS_ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' --output text)
          
          echo "RDS endpoint: $RDS_ENDPOINT"
          echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
          
          # Modify the RDS instance to be publicly accessible if it's not already
          PUBLICLY_ACCESSIBLE=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].PubliclyAccessible' --output text)
            
          if [ "$PUBLICLY_ACCESSIBLE" = "false" ]; then
            echo "Modifying RDS instance to be publicly accessible..."
            aws rds modify-db-instance \
              --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
              --publicly-accessible \
              --apply-immediately
              
            echo "Waiting for RDS instance to be updated..."
            aws rds wait db-instance-available \
              --db-instance-identifier ${{ env.RDS_DB_INSTANCE }}
          fi
          
          # Get the security group ID for the RDS instance
          RDS_SG_ID=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].VpcSecurityGroups[0].VpcSecurityGroupId' \
            --output text)
            
          # Add inbound rule to allow connections from anywhere
          echo "Updating security group to allow public access..."
          aws ec2 authorize-security-group-ingress \
            --group-id $RDS_SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 \
            || echo "Rule for public access already exists"
        else
          echo "Creating new RDS PostgreSQL instance..."
          
          # Create a security group for the RDS instance - add error handling
          RDS_SG_NAME="marketplace-db-sg"
          
          # Check if security group already exists
          SG_CHECK=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$RDS_SG_NAME" --query 'SecurityGroups[0].GroupId' --output text)
          
          if [[ "$SG_CHECK" == "None" || -z "$SG_CHECK" ]]; then
            echo "Creating new security group $RDS_SG_NAME"
            RDS_SG_ID=$(aws ec2 create-security-group \
              --group-name $RDS_SG_NAME \
              --description "Security group for Marketplace RDS" \
              --output text --query 'GroupId')
          else
            echo "Security group $RDS_SG_NAME already exists, using existing one"
            RDS_SG_ID=$SG_CHECK
          fi
          
          echo "Using security group: $RDS_SG_ID"
          
          # Allow access from the EC2 instance
          EC2_PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          aws ec2 authorize-security-group-ingress \
            --group-id $RDS_SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr $EC2_PUBLIC_IP/32 \
            || echo "Rule for EC2 instance already exists"
          
          # Allow public access for pgAdmin connections
          aws ec2 authorize-security-group-ingress \
            --group-id $RDS_SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 \
            || echo "Rule for public access already exists"
          
          # Create the RDS instance with public access
          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --engine-version 15 \
            --allocated-storage 20 \
            --master-username ${{ env.RDS_DB_USER }} \
            --master-user-password "${{ env.RDS_DB_PASSWORD }}" \
            --vpc-security-group-ids $RDS_SG_ID \
            --backup-retention-period ${{ env.RDS_BACKUP_RETENTION }} \
            --publicly-accessible \
            --db-name ${{ env.RDS_DB_NAME }}
          
          echo "Waiting for RDS instance to be available..."
          aws rds wait db-instance-available \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }}
          
          # Get RDS endpoint
          RDS_ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' --output text)
          
          echo "RDS instance created with endpoint: $RDS_ENDPOINT"
          echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        fi
        
        # Create database URL for the application - ensure RDS_ENDPOINT is set
        if [ -z "$RDS_ENDPOINT" ]; then
          echo "Error: RDS_ENDPOINT is not set, cannot create database URL"
          exit 1
        fi
        
        DB_URL="postgresql://${{ env.RDS_DB_USER }}:${{ env.RDS_DB_PASSWORD }}@$RDS_ENDPOINT:5432/${{ env.RDS_DB_NAME }}"
        echo "DB_URL=$DB_URL" >> $GITHUB_ENV
        
        # Print connection info for pgAdmin
        echo "---------------------------------------------"
        echo "RDS Connection Info for pgAdmin:"
        echo "Hostname: $RDS_ENDPOINT"
        echo "Port: 5432"
        echo "Database: ${{ env.RDS_DB_NAME }}"
        echo "Username: ${{ env.RDS_DB_USER }}"
        echo "Password: ${{ env.RDS_DB_PASSWORD }}"
        echo "---------------------------------------------"

    # Deploy to EC2
    - name: Deploy to EC2
      run: |
        echo "Deploying application to EC2 instance..."
        
        # Verify that DB_URL is set
        if [ -z "$DB_URL" ]; then
          echo "Error: Database URL is not set"
          exit 1
        fi
        
        # Transfer deployment package to the server
        scp -i ~/.ssh/ec2_key.pem deployment.zip ec2-user@${{ env.EC2_HOST }}:~/deployment.zip
        
        if [ $? -ne 0 ]; then
          echo "Error: Failed to transfer deployment package to EC2"
          exit 1
        fi
        
        # Connect to server and deploy
        ssh -i ~/.ssh/ec2_key.pem ec2-user@${{ env.EC2_HOST }} << EOF
          echo "Connected to EC2 instance in London region"
          
          # Create directory for the app if it doesn't exist
          mkdir -p ~/app
          
          # Backup current deployment if it exists
          if [ -d ~/app/current ]; then
            timestamp=\$(date +%Y%m%d%H%M%S)
            mkdir -p ~/app/backup
            mv ~/app/current ~/app/backup/backup_\$timestamp
          fi
          
          # Create new deployment directory
          mkdir -p ~/app/current
          
          # Extract deployment package
          unzip -o ~/deployment.zip -d ~/app/current
          
          # Create .env file with database connection info
          cat > ~/app/current/.env << EOL
NODE_ENV=production
DATABASE_URL=${DB_URL}
DATABASE_SSL=true
JWT_SECRET=${{ secrets.JWT_SECRET }}
PORT=3000
EOL
          
          # Install production dependencies
          cd ~/app/current
          npm install --production
          
          # Install PM2 if not already installed
          if ! command -v pm2 &> /dev/null; then
            echo "Installing PM2..."
            npm install -g pm2
          fi
          
          # Stop existing PM2 process if running
          pm2 stop marketplace 2>/dev/null || true
          
          # Start application with PM2
          echo "Starting application..."
          pm2 start server.js --name marketplace
          
          # Save PM2 process list to resurrect after reboot
          pm2 save
          
          # Setup PM2 to start on system startup if not already set
          pm2 startup | grep -v "sudo" | sh
          
          # Clean up deployment package
          rm ~/deployment.zip
          
          echo "Deployment completed successfully!"
EOF

    # Verify deployment
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        sleep 5
        
        # Use curl to check if the application is responding
        response_code=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.EC2_HOST }}:3000 || echo "failed")
        
        if [[ $response_code == "200" ]]; then
          echo "✅ Application successfully deployed and responding with status code 200"
          echo "Application URL: http://${{ env.EC2_HOST }}:3000"
        else
          echo "⚠️ Application check returned status code: $response_code"
          echo "It may take a few moments for the application to fully start"
          echo "Application URL: http://${{ env.EC2_HOST }}:3000"
          
          # Don't fail the workflow, as the app might just need more time to start
          echo "Deployment completed, but application verification needs manual check"
        fi