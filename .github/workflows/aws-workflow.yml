name: Deploy to Amazon EC2 - London

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: eu-west-2                     # London region
  EC2_HOST: ${{ secrets.EC2_HOST }}         # Get from secrets instead of hardcoding
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }} # Get from secrets instead of hardcoding
  NODE_VERSION: '18.x'                      # matches your engine requirements in package.json
  RDS_DB_INSTANCE: my-database              # RDS instance identifier
  RDS_DB_NAME: my-marketplace               # Database name
  RDS_DB_USER: marketplace_user             # Database user
  RDS_BACKUP_RETENTION: 7                   # Days to keep automated backups
  # RDS_DB_PASSWORD moved to secrets

permissions:
  contents: read
  id-token: write  # Required for requesting the JWT

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    # Install canvas dependencies before any npm operations
    - name: Install system dependencies for canvas
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libcairo2-dev libpango1.0-dev libjpeg-dev libgif-dev librsvg2-dev

    # Install global dependencies first
    - name: Install node-pre-gyp globally
      run: sudo npm install -g node-pre-gyp
      
    # Use --unsafe-perm for npm install to avoid permission issues
    - name: npm install
      run: npm install --no-bin-links --unsafe-perm

    # Fix permissions for all binaries in node_modules/.bin
    - name: Fix permissions for node binaries
      run: |
        find node_modules/.bin -type f -exec chmod +x {} \;
        echo "Fixed permissions for binaries in node_modules/.bin"

    # Rebuild canvas with --unsafe-perm and fallback message
    - name: Rebuild canvas module
      run: npm rebuild canvas --update-binary --unsafe-perm || echo "Canvas rebuild failed but continuing"

    # Build step
    - name: Build
      run: npm run build --if-present
      env:
        NODE_ENV: test
        TEST_DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}

    # Separate test step with explicit path to Jest binary
    - name: Run tests
      run: |
        # Ensure Jest binary is executable
        chmod +x node_modules/.bin/jest
        node_modules/.bin/jest --passWithNoTests
      env:
        NODE_ENV: test
        TEST_DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        
    # Create deployment package
    - name: Create deployment package
      run: |
        # Create a directory for production files
        mkdir -p dist
        
        # Copy necessary files for deployment (excluding development files)
        rsync -av --exclude='.git' --exclude='.github' --exclude='node_modules' --exclude='tests' \
          --exclude='*.md' --exclude='*.env' --exclude='*.log' . dist/
        
        # Create package.json without dev dependencies for production
        jq 'del(.devDependencies)' package.json > dist/package.json
        
        # Create deployment archive
        cd dist && zip -r ../deployment.zip . 
        cd .. 
        echo "Created deployment package: deployment.zip"

    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: deployment.zip

  deploy:
    name: Deploy
    needs: build
    runs-on: ubuntu-latest
    # Fix for "Skip setting environment url" error
    environment:
      name: 'Production'
      url: http://18.168.205.177:3000  # Use hardcoded URL instead of env reference

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app
        
    # Configure AWS credentials with explicit error handling
    - name: Configure AWS credentials
      id: aws-credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: true

    # Enhanced AWS CLI verification with better error messages
    - name: Verify AWS CLI
      run: |
        # Print AWS CLI version for debugging
        aws --version
        
        echo "Testing AWS credentials with basic command..."
        if ! aws sts get-caller-identity --query "Account" --output text > /dev/null 2>&1; then
          echo "ERROR: AWS authentication failed. Possible causes:"
          echo "1. AWS_ACCESS_KEY_ID or AWS_SECRET_ACCESS_KEY may be incorrect"
          echo "2. The IAM user/role may not have sufficient permissions"
          echo "3. AWS_REGION (${{ env.AWS_REGION }}) may be incorrect"
          exit 1
        fi
        
        echo "AWS authentication successful!"
        
        # Print last few characters of the account ID for verification without exposing full ID
        ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
        echo "Connected to AWS account ending in: ...${ACCOUNT_ID: -4}"
        
    # Simplified EC2 instance status check with better error handling
    - name: Check EC2 instance status
      run: |
        echo "Checking EC2 instance ID format..."
        EC2_ID="${{ secrets.EC2_INSTANCE_ID }}"
        
        # Echo part of the ID for debugging without exposing full ID
        echo "Instance ID ends with: ...${EC2_ID: -4}"
        
        # Validate format first
        if [[ ! "$EC2_ID" =~ ^i-[a-z0-9]+$ ]]; then
          echo "ERROR: Malformed EC2 instance ID. Should start with 'i-' followed by alphanumeric characters."
          exit 1
        fi
        
        echo "Verifying EC2 instance exists..."
        if ! aws ec2 describe-instance-status --instance-ids "$EC2_ID" > /dev/null 2>&1; then
          echo "ERROR: EC2 instance validation failed. Possible causes:"
          echo "1. Instance ID may not exist"
          echo "2. Instance may be in a different region than ${{ env.AWS_REGION }}"
          echo "3. IAM credentials may not have ec2:DescribeInstances permission"
          
          # Try listing available instances to help debugging
          echo "Available instances in region ${{ env.AWS_REGION }}:"
          aws ec2 describe-instances --query "Reservations[*].Instances[*].[InstanceId]" --output text
          
          exit 1
        fi

        echo "EC2 instance validation successful!"
        
        # Get and check instance state more carefully
        echo "Getting instance state..."
        INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids "$EC2_ID" \
          --query "Reservations[0].Instances[0].State.Name" --output text || echo "error")
          
        if [ "$INSTANCE_STATE" = "error" ]; then
          echo "ERROR: Failed to get instance state"
          exit 1
        elif [ "$INSTANCE_STATE" != "running" ]; then
          echo "Instance is not running. Current state: $INSTANCE_STATE"
          echo "Starting the instance..."
          aws ec2 start-instances --instance-ids "$EC2_ID" > /dev/null
          
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids "$EC2_ID"
          
          echo "Instance is now running. Waiting 30 seconds for services to start..."
          sleep 30
        else
          echo "Instance is already running."
        fi

    # Setup SSH
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
        chmod 600 ~/.ssh/ec2_key.pem
        
        # Add the host to known_hosts to avoid prompt during connection
        ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts

    # Check if RDS instance exists, create if it doesn't
    - name: Check RDS instance
      run: |
        echo "Checking if RDS instance exists..."
        
        # Check if the RDS instance already exists - without logging details
        if aws rds describe-db-instances --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} > /dev/null 2>&1; then
          echo "RDS instance ${{ env.RDS_DB_INSTANCE }} already exists"
          
          # Get RDS endpoint
          RDS_ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' --output text)
          
          echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
          
          # Modify the RDS instance to be publicly accessible if it's not already
          PUBLICLY_ACCESSIBLE=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].PubliclyAccessible' --output text)
            
          if [ "$PUBLICLY_ACCESSIBLE" = "false" ]; then
            echo "Modifying RDS instance to be publicly accessible..."
            aws rds modify-db-instance \
              --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
              --publicly-accessible \
              --apply-immediately
              
            echo "Waiting for RDS instance to be updated..."
            aws rds wait db-instance-available \
              --db-instance-identifier ${{ env.RDS_DB_INSTANCE }}
          fi
          
          # Get the security group ID for the RDS instance
          RDS_SG_ID=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].VpcSecurityGroups[0].VpcSecurityGroupId' \
            --output text)
            
          # Add inbound rule to allow connections from anywhere
          echo "Updating security group to allow public access..."
          aws ec2 authorize-security-group-ingress \
            --group-id $RDS_SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 \
            || echo "Rule for public access already exists"
        else
          echo "Creating new RDS PostgreSQL instance..."
          
          # Create a security group for the RDS instance - add error handling
          RDS_SG_NAME="marketplace-db-sg"
          
          # Check if security group already exists
          SG_CHECK=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$RDS_SG_NAME" --query 'SecurityGroups[0].GroupId' --output text)
          
          if [[ "$SG_CHECK" == "None" || -z "$SG_CHECK" ]]; then
            echo "Creating new security group $RDS_SG_NAME"
            RDS_SG_ID=$(aws ec2 create-security-group \
              --group-name $RDS_SG_NAME \
              --description "Security group for Marketplace RDS" \
              --output text --query 'GroupId')
          else
            echo "Security group $RDS_SG_NAME already exists, using existing one"
            RDS_SG_ID=$SG_CHECK
          fi
          
          echo "Using security group: $RDS_SG_ID"
          
          # Allow access from the EC2 instance
          EC2_PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ env.EC2_INSTANCE_ID }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          
          aws ec2 authorize-security-group-ingress \
            --group-id $RDS_SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr $EC2_PUBLIC_IP/32 \
            || echo "Rule for EC2 instance already exists"
          
          # Allow public access for pgAdmin connections
          aws ec2 authorize-security-group-ingress \
            --group-id $RDS_SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 \
            || echo "Rule for public access already exists"
          
          # Create the RDS instance with public access
          aws rds create-db-instance \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --engine-version 15 \
            --allocated-storage 20 \
            --master-username ${{ env.RDS_DB_USER }} \
            --master-user-password "${{ secrets.RDS_DB_PASSWORD }}" \
            --vpc-security-group-ids $RDS_SG_ID \
            --backup-retention-period ${{ env.RDS_BACKUP_RETENTION }} \
            --publicly-accessible \
            --db-name ${{ env.RDS_DB_NAME }}
          
          echo "Waiting for RDS instance to be available..."
          aws rds wait db-instance-available \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }}
          
          # Get RDS endpoint
          RDS_ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier ${{ env.RDS_DB_INSTANCE }} \
            --query 'DBInstances[0].Endpoint.Address' --output text)
          
          echo "RDS instance created with endpoint: $RDS_ENDPOINT"
          echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        fi
        
        # Create database URL for the application - ensure RDS_ENDPOINT is set
        if [ -z "$RDS_ENDPOINT" ]; then
          echo "Error: RDS_ENDPOINT is not set, cannot create database URL"
          exit 1
        fi
        
        DB_URL="postgresql://${{ env.RDS_DB_USER }}:${{ secrets.RDS_DB_PASSWORD }}@$RDS_ENDPOINT:5432/${{ env.RDS_DB_NAME }}"
        echo "DB_URL=$DB_URL" >> $GITHUB_ENV
        
        # Print connection info for pgAdmin without exposing password
        echo "---------------------------------------------"
        echo "RDS Connection Info for pgAdmin:"
        echo "Hostname: $RDS_ENDPOINT"
        echo "Port: 5432"
        echo "Database: ${{ env.RDS_DB_NAME }}"
        echo "Username: ${{ env.RDS_DB_USER }}"
        echo "Password: [REDACTED - Stored in GitHub Secrets]"
        echo "---------------------------------------------"

    # Deploy to EC2 with improved error handling
    - name: Deploy to EC2
      run: |
        set -x  # Print commands before execution
        echo "Deploying application to EC2 instance..."
        
        # Verify essential variables
        if [ -z "${{ env.EC2_HOST }}" ]; then
          echo "Error: EC2_HOST is not set. Check your GitHub secrets."
          exit 1
        fi
        
        # Verify that DB_URL is set
        if [ -z "$DB_URL" ]; then
          echo "Error: Database URL is not set"
          exit 1
        fi
        
        # Create environment file locally
        echo "NODE_ENV=production" > env_file
        echo "TEST_DATABASE_URL=$DB_URL" >> env_file
        echo "DATABASE_SSL=true" >> env_file
        echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> env_file
        echo "PORT=3000" >> env_file
        
        # Transfer files to EC2
        scp -i ~/.ssh/ec2_key.pem deployment.zip ec2-user@${{ env.EC2_HOST }}:~/deployment.zip || {
          echo "Failed to transfer deployment package. Check EC2_HOST and SSH key."
          exit 1
        }
        
        scp -i ~/.ssh/ec2_key.pem env_file ec2-user@${{ env.EC2_HOST }}:~/env_file || {
          echo "Failed to transfer env file. Check EC2_HOST and SSH key."
          exit 1
        }
        
        # Execute deployment commands on EC2
        ssh -i ~/.ssh/ec2_key.pem ec2-user@${{ env.EC2_HOST }} "
          echo 'Connected to EC2 instance in London region' &&
          mkdir -p ~/app &&
          
          # Backup current deployment if it exists
          if [ -d ~/app/current ]; then
            timestamp=\$(date +%Y%m%d%H%M%S) &&
            mkdir -p ~/app/backup &&
            mv ~/app/current ~/app/backup/backup_\$timestamp
          fi &&
          
          # Deploy new version
          mkdir -p ~/app/current &&
          unzip -o ~/deployment.zip -d ~/app/current &&
          mv ~/env_file ~/app/current/.env &&
          cd ~/app/current &&
          npm install --production &&
          
          # Setup and start PM2
          if ! command -v pm2 &> /dev/null; then
            npm install -g pm2
          fi &&
          pm2 stop marketplace 2>/dev/null || true &&
          pm2 start server.js --name marketplace &&
          pm2 save &&
          pm2 startup | grep -v 'sudo' | sh &&
          
          # Cleanup
          rm ~/deployment.zip &&
          echo 'Deployment completed successfully!'
        "

    # Verify deployment
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        sleep 5
        
        # Use curl to check if the application is responding
        response_code=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.EC2_HOST }}:3000 || echo "failed")
        
        if [[ $response_code == "200" ]]; then
          echo "✅ Application successfully deployed and responding with status code 200"
          echo "Application URL: http://${{ env.EC2_HOST }}:3000"
        else
          echo "⚠️ Application check returned status code: $response_code"
          echo "It may take a few moments for the application to fully start"
          echo "Application URL: http://${{ env.EC2_HOST }}:3000"
          
          # Don't fail the workflow, as the app might just need more time to start
          echo "Deployment completed, but application verification needs manual check"
        fi